
    <html>
    <head>
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/foundation/5.5.2/css/foundation.min.css">
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <style>
    html,
    body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
    }
    
    html {
        overflow-x: hidden;
    }
    
    @keyframes squeezeBody {
        from { width: 100%; }
        to { width: calc(100% - 300px); }
    }
    
    @-webkit-keyframes squeezeBody {
        from { width: 100%; }
        to { width: calc(100% - 300px); }
    }
    
    @keyframes stretchBody {
        from { width: calc(100% - 300px); }
        to { width: 100%; }
    }
    
    @-webkit-keyframes stretchBody {
        from { width: calc(100% - 300px); }
        to { width: 100%; }
    }
    
    h1, h2, h3, h4, h5, h6 {
        font-family: 'Old Standard TT', serif;
        font-weight: bold;
    }
    
    h3 {
        border-bottom: 1px solid #ddd;
    }
    
    .serif {
        font-family: 'Old Standard TT', serif;
    }
    
    .top-bar {
        height: 45px;
        min-height: 45px;
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
    }
    
    .bars-lnk {
        color: #fff;
    }
    
    .bars-lnk i {
        display: inline-block;
        margin-left: 10px;
        margin-top: 7px;
    }
    
    .bars-lnk img {
        display: inline-block;
        margin-left: 10px;
        margin-top: -15px;
        margin-right: 15px;
        height: 35px;
    }
    
    .lateral-menu {
        background-color: #333;
        color: rgb(144, 144, 144);
        width: 300px;
        font-family: 'Open Sans', 'Myriad Pro', 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', Geneva, Verdana, sans-serif;
    }
    
    .lateral-menu label {
        color: rgb(144, 144, 144);
    }
    
    .lateral-menu-content {
        padding-left: 10px;
        height: 100%;
        font-size: 12px;
        font-style: normal;
        font-variant: normal;
        font-weight: bold;
        line-height: 16px;
    }
    
    .lateral-menu-content .title{
        padding-top: 15px;
        font-size: 2em;
        height: 45px;
    }
    
    .lateral-menu-content-inner {
        overflow-y: auto;
        height: 100%;
        padding-top: 10px;
        padding-bottom: 50px;
        padding-right: 10px;
        font-size: 0.9em;
    }
    
    
    
    .container {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        justify-content: center;
        align-items: stretch;
        width: 100%;
        height: 100%;
        padding-top: 65px;
    }
    
    .container>* {
        display: block;
        width: 50%;
        margin-left: 10px;
        margin-right: 10px;
        max-height: 100%;
    }
    
    .container textarea {
        resize: none;
        font-family: Consolas,"Liberation Mono",Courier,monospace;
        height: 97%;
        max-height: 97%;
        width: 45%;
    }
    
    #preview {
        height: 97%;
        max-height: 97%;
        border: 1px solid #eee;
        overflow-y: scroll;
        width: 55%;
        padding: 10px;
    }
    
    pre {
        white-space: pre-wrap;       /* css-3 */
        white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
        white-space: -pre-wrap;      /* Opera 4-6 */
        white-space: -o-pre-wrap;    /* Opera 7 */
        word-wrap: break-word;       /* Internet Explorer 5.5+ */
        background-color: #f8f8f8;
        border: 1px solid #dfdfdf;
        margin-top: 1.5em;
        margin-bottom: 1.5em;
        padding: 0.125rem 0.3125rem 0.0625rem;
    }
    
    pre code {
        background-color: transparent;
        border: 0;
        padding: 0;
    }
    
    
    .modal-wrapper {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: 999;
        background-color: rgba(51,51,51,0.5);
    }
    
    .modal-inner {
        margin-top: 200px;
        margin-left: auto;
        margin-right: auto;
        width: 600px;
        height: 225px;
        background-color: #fff;
        opacity: 1;
        z-index: 1000;
    }
    
    .modal-close-btn {
        float: right;
        display: inline-block;
        margin-right: 5px;
        color: #ff4336;
    }
    
    .modal-close-btn:hover {
        float: right;
        display: inline-block;
        margin-right: 5px;
        color: #8d0002;
    }
    
    .modal-topbar {
        clear: both;
        height: 25px;
    }
    
    .modal-inner .link-area {
        margin: 10px;
        height: 170px;
    
    }
    
    .modal-inner textarea {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
    }
    
    .version {
        color: white;
        font-size: 0.8em !important;
    }
    body {
        padding-left: 20px;
        padding-right: 20px;
    }
    </style>
    </head>
    <body>
    <h1 id="solidity-api">Solidity API</h1>
<h2 id="customproposal">CustomProposal</h2>
<p>This contract is designed for constructing proposals from user input. The methods generate calldata from the input arguments and pass it to the specified pool as a proposal.</p>
<p><em>It is a supporting part of the protocol that takes user input arguments and constructs OZ Governor-compatible structures describing the transactions to be executed upon successful voting on the proposal. It does not store user input, but only passes it on in a transformed format to the specified pool contract.</em></p>
<h3 id="service">service</h3>
<pre><code class="solidity language-solidity">contract IService service</code></pre>
<p><em>The address of the Service contract.</em></p>
<h3 id="onlyservice">onlyService</h3>
<pre><code class="solidity language-solidity">modifier onlyService()</code></pre>
<p>Modifier that makes the function callable only by the Service contract.</p>
<p><em>Allows the function to be executed only if the address sending the transaction is equal to the address of the Service contract stored in the memory of this contract.</em></p>
<h3 id="onlyforpool">onlyForPool</h3>
<pre><code class="solidity language-solidity">modifier onlyForPool(address pool)</code></pre>
<p>Modifier that checks the existence of a pool at the given address.</p>
<p><em>Checks the existence of the pool for which the proposal is being constructed. The pool should store the same Service contract address as stored in the Custom Proposal contract and be registered in the Registry contract with the corresponding type.</em></p>
<h3 id="constructor-NaN">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<p>Contract constructor.</p>
<p><em>This contract uses OpenZeppelin upgrades and has no need for a constructor function.
The constructor is replaced with an initializer function.
This method disables the initializer feature of the OpenZeppelin upgrades plugin, preventing the initializer methods from being misused.</em></p>
<h3 id="initialize">initialize</h3>
<pre><code class="solidity language-solidity">function initialize() public</code></pre>
<p>Contract initializer</p>
<p><em>This method replaces the constructor for upgradeable contracts.</em></p>
<h3 id="setservice">setService</h3>
<pre><code class="solidity language-solidity">function setService(address service_) external</code></pre>
<p><em>Stores a new address of the Service contract in the memory of this contract.</em></p>
<h4 id="parameters">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>service_</td>
<td>address</td>
<td>The new address of the Service contract.</td>
</tr>
</tbody>
</table>
<h3 id="proposetransfer">proposeTransfer</h3>
<pre><code class="solidity language-solidity">function proposeTransfer(address pool, address asset, address[] recipients, uint256[] amounts, string description, string metaHash) external returns (uint256 proposalId)</code></pre>
<p>This proposal is the only way to withdraw funds from the pool account.</p>
<p><em>This function prepares a proposal from the list of recipients and corresponding amounts and submits it to the pool for a vote to transfer those amounts to the specified recipients. The asset type is specified as a separate argument, which is the same for all recipients.</em></p>
<h4 id="parameters-1">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>The address of the pool on behalf of which this proposal will be launched and from whose balance the values will be transferred.</td>
</tr>
<tr>
<td>asset</td>
<td>address</td>
<td>Asset to transfer (address(0) for ETH transfers).</td>
</tr>
<tr>
<td>recipients</td>
<td>address[]</td>
<td>Transfer recipients.</td>
</tr>
<tr>
<td>amounts</td>
<td>uint256[]</td>
<td>Transfer amounts.</td>
</tr>
<tr>
<td>description</td>
<td>string</td>
<td>Proposal description.</td>
</tr>
<tr>
<td>metaHash</td>
<td>string</td>
<td>Hash value of proposal metadata.</td>
</tr>
</tbody>
</table>
<h4 id="return-values">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>The ID of the created proposal.</td>
</tr>
</tbody>
</table>
<h3 id="proposetge">proposeTGE</h3>
<pre><code class="solidity language-solidity">function proposeTGE(address pool, address token, struct ITGE.TGEInfo tgeInfo, struct IToken.TokenInfo tokenInfo, string metadataURI, string description, string metaHash) external returns (uint256 proposalId)</code></pre>
<p>This proposal is launched when there is a need to issue additional tokens (both Governance and Preference) for an existing pool. In other words, the issuance of tokens for any DAO is possible only through the creation of such a proposal.</p>
<p><em>Proposal to launch a new token generation event (TGE). It can only be created if the maximum supply threshold value for an existing token has not been reached or if a new token is being created, in which case a new token contract will be deployed simultaneously with the TGE contract.</em></p>
<h4 id="parameters-2">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>The address of the pool on behalf of which this proposal will be launched and for which the TGE event will be launched.</td>
</tr>
<tr>
<td>token</td>
<td>address</td>
<td></td>
</tr>
<tr>
<td>tgeInfo</td>
<td>struct ITGE.TGEInfo</td>
<td>TGE parameters.</td>
</tr>
<tr>
<td>tokenInfo</td>
<td>struct IToken.TokenInfo</td>
<td>Token parameters.</td>
</tr>
<tr>
<td>metadataURI</td>
<td>string</td>
<td>TGE metadata URI.</td>
</tr>
<tr>
<td>description</td>
<td>string</td>
<td>Proposal description.</td>
</tr>
<tr>
<td>metaHash</td>
<td>string</td>
<td>Hash value of proposal metadata.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-1">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>The ID of the created proposal.</td>
</tr>
</tbody>
</table>
<h3 id="proposegovernancesettings">proposeGovernanceSettings</h3>
<pre><code class="solidity language-solidity">function proposeGovernanceSettings(address pool, struct IGovernanceSettings.NewGovernanceSettings settings, string description, string metaHash) external returns (uint256 proposalId)</code></pre>
<p>Proposal to replace Governance settings. One of the two methods to change voting parameters.</p>
<p><em>The main parameter should be a structure of type NewGovernanceSettings, which includes the Governance Threshold, Decision Threshold, Proposal Threshold, and execution delay lists for proposals.</em></p>
<h4 id="parameters-3">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>The address of the pool on behalf of which this proposal will be launched and for which the Governance settings will be changed.</td>
</tr>
<tr>
<td>settings</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>New governance settings.</td>
</tr>
<tr>
<td>description</td>
<td>string</td>
<td>Proposal description.</td>
</tr>
<tr>
<td>metaHash</td>
<td>string</td>
<td>Hash value of proposal metadata.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-2">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>The ID of the created proposal.</td>
</tr>
</tbody>
</table>
<h3 id="proposecustomtx">proposeCustomTx</h3>
<pre><code class="solidity language-solidity">function proposeCustomTx(address pool, address[] targets, uint256[] values, bytes[] callDatas, string description, string metaHash) external returns (uint256 proposalId)</code></pre>
<p>Creating a custom proposal.</p>
<p><em>This tool can be useful for creating a transaction with arbitrary parameters and putting it to a vote for execution on behalf of the pool.</em></p>
<h4 id="parameters-4">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>The address of the pool on behalf of which this proposal will be launched.</td>
</tr>
<tr>
<td>targets</td>
<td>address[]</td>
<td>Transfer recipients.</td>
</tr>
<tr>
<td>values</td>
<td>uint256[]</td>
<td>Transfer amounts for payable.</td>
</tr>
<tr>
<td>callDatas</td>
<td>bytes[]</td>
<td>Raw calldatas.</td>
</tr>
<tr>
<td>description</td>
<td>string</td>
<td>Proposal description.</td>
</tr>
<tr>
<td>metaHash</td>
<td>string</td>
<td>Hash value of proposal metadata.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-3">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>The ID of the created proposal.</td>
</tr>
</tbody>
</table>
<h3 id="proposetgeerc1155">proposeTGEERC1155</h3>
<pre><code class="solidity language-solidity">function proposeTGEERC1155(address pool, address token, uint256 tokenId, string tokenIdMetadataURI, struct ITGE.TGEInfo tgeInfo, struct IToken.TokenInfo tokenInfo, string metadataURI, string description, string metaHash) external returns (uint256 proposalId)</code></pre>
<p>This proposal is launched when there is a need to issue ERC1155 Preference tokens, additional collections, and token units in existing collections for an existing ERC1155 token. In other words, the issuance of tokens of this format for any DAO is possible only through the creation of such a proposal.</p>
<p><em>Proposal to launch a new token generation event (TGE) for ERC1155 preference tokens.</em></p>
<h4 id="parameters-5">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td></td>
</tr>
<tr>
<td>token</td>
<td>address</td>
<td></td>
</tr>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>Token ID.</td>
</tr>
<tr>
<td>tokenIdMetadataURI</td>
<td>string</td>
<td>Token ID metadata URI.</td>
</tr>
<tr>
<td>tgeInfo</td>
<td>struct ITGE.TGEInfo</td>
<td>TGE parameters.</td>
</tr>
<tr>
<td>tokenInfo</td>
<td>struct IToken.TokenInfo</td>
<td>Token parameters.</td>
</tr>
<tr>
<td>metadataURI</td>
<td>string</td>
<td>TGE metadata URI.</td>
</tr>
<tr>
<td>description</td>
<td>string</td>
<td>Proposal description.</td>
</tr>
<tr>
<td>metaHash</td>
<td>string</td>
<td>Hash value of proposal metadata.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-4">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>The ID of the created proposal.</td>
</tr>
</tbody>
</table>
<h3 id="proposegovernancesettingswithroles">proposeGovernanceSettingsWithRoles</h3>
<pre><code class="solidity language-solidity">function proposeGovernanceSettingsWithRoles(address pool, struct IGovernanceSettings.NewGovernanceSettings settings, address[] secretary, address[] executor, string description, string metaHash) external returns (uint256 proposalId)</code></pre>
<p>Proposal to replace Governance settings and change the pool's list of secretaries and executors. One of the two methods to change voting parameters. The only way for a DAO to modify the lists of secretaries and executors.</p>
<p><em>The main parameter should be a structure of type NewGovernanceSettings, which includes the Governance Threshold, Decision Threshold, Proposal Threshold, execution delay lists for proposals, as well as two sets of addresses: one for the new list of secretaries and another for the new list of executors.</em></p>
<h4 id="parameters-6">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>The address of the pool on behalf of which this proposal will be launched and for which the Governance settings will be changed.</td>
</tr>
<tr>
<td>settings</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>New governance settings.</td>
</tr>
<tr>
<td>secretary</td>
<td>address[]</td>
<td>Add a new address to the pool's secretary list.</td>
</tr>
<tr>
<td>executor</td>
<td>address[]</td>
<td>Add a new address to the pool's executor list.</td>
</tr>
<tr>
<td>description</td>
<td>string</td>
<td>Proposal description.</td>
</tr>
<tr>
<td>metaHash</td>
<td>string</td>
<td>Hash value of the proposal metadata.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-5">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>The ID of the created proposal.</td>
</tr>
</tbody>
</table>
<h2 id="invoice">Invoice</h2>
<p>This contract is designed for managing invoices issued by pools for payment.</p>
<p>_It supports both trusted (payment confirmation off-chain by an authorized address) and trustless (on-chain payment) modes of operation.<br />
Regardless of the presence of Governance tokens in delegation or balance, and regardless of the owner/creator pool status, any address can act as an invoice payer. The following conditions must be met:</p>
<ul>
<li>The structure Invoice.sol:invoices for the selected invoice number stores either an empty InvoiceInfo.core.whitelist[] (public invoice), or it contains the payer's address</li>
<li>The structure Invoice.sol:invoices for the selected invoice number has the values false in the fields InvoiceInfo.isPaid and InvoiceInfo.isCanceled (the invoice has not been canceled or paid by anyone yet)</li>
<li>The current network block is less than the InvoiceInfo.core.expirationBlock stored in the structure Invoice.sol:invoices for the selected invoice number</li>
</ul>
<p>When paying the invoice, the amount specified by the invoice creator is debited in the units they have chosen (ERC20 tokens or ETH).</p>
<p><em>Note. All the above is valid for on-chain invoice payments. For off-chain invoice payments, a 3rd party backend solution is used to verify the payment of the specified invoice and has its mechanisms for allowing or disallowing the user to pay, including KYC. There is no such blockchain payer in this approach; the invoice is marked as paid by the address assigned the role of SERVICE_MANAGER in the Service contract._</em></p>
<h3 id="registry">registry</h3>
<pre><code class="solidity language-solidity">contract IRegistry registry</code></pre>
<p>Адрес контракта Registry</p>
<h3 id="lastinvoiceidforpool">lastInvoiceIdForPool</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; uint256) lastInvoiceIdForPool</code></pre>
<p>Последние созданные пулами инвойсы</p>
<p><em>Маппинг, содержащий последний (максимальный) номер инвойса для каждого пула</em></p>
<h3 id="invoices">invoices</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; mapping(uint256 =&gt; struct IInvoice.InvoiceInfo)) invoices</code></pre>
<p>Invoice data (including their state)</p>
<p><em>Mapping that stores nested mappings of invoice structures for each pool (pool address is used as the key)</em></p>
<h3 id="eventindex">eventIndex</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; mapping(uint256 =&gt; uint256)) eventIndex</code></pre>
<p>Global enumeration of invoices</p>
<p><em>For each pool and for each invoice issued by the pool, the mapping contains global event IDs under which the invoices were registered in the Registry contract.</em></p>
<h3 id="invoicecreated">InvoiceCreated</h3>
<pre><code class="solidity language-solidity">event InvoiceCreated(address pool, uint256 invoiceId)</code></pre>
<p><em>Event emitted on invoice creating</em></p>
<h4 id="parameters-7">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
<tr>
<td>invoiceId</td>
<td>uint256</td>
<td>InvoiceId for Pool</td>
</tr>
</tbody>
</table>
<h3 id="invoicecanceled">InvoiceCanceled</h3>
<pre><code class="solidity language-solidity">event InvoiceCanceled(address pool, uint256 invoiceId)</code></pre>
<p><em>Event emitted when invoice is canceled</em></p>
<h4 id="parameters-8">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
<tr>
<td>invoiceId</td>
<td>uint256</td>
<td>InvoiceId for Pool</td>
</tr>
</tbody>
</table>
<h3 id="invoicepaid">InvoicePaid</h3>
<pre><code class="solidity language-solidity">event InvoicePaid(address pool, uint256 invoiceId)</code></pre>
<p><em>Event emitted when invoice is paid</em></p>
<h4 id="parameters-9">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
<tr>
<td>invoiceId</td>
<td>uint256</td>
<td>InvoiceId for Pool</td>
</tr>
</tbody>
</table>
<h3 id="onlyvalidinvoicemanager">onlyValidInvoiceManager</h3>
<pre><code class="solidity language-solidity">modifier onlyValidInvoiceManager(address pool)</code></pre>
<p>Modifier that allows creating and canceling invoices for a given pool.</p>
<p><em>The logic of the modifier is described in the isValidInvoiceManager method. The modifier forwards the arguments to this method and uses its boolean output.</em></p>
<h3 id="onlymanager">onlyManager</h3>
<pre><code class="solidity language-solidity">modifier onlyManager()</code></pre>
<p><em>Modifier to allow only the service manager to call a function.</em></p>
<h3 id="whenpoolnotpaused">whenPoolNotPaused</h3>
<pre><code class="solidity language-solidity">modifier whenPoolNotPaused(address pool)</code></pre>
<p><em>Modifier to check if the pool is not paused.</em></p>
<h3 id="onlyactive">onlyActive</h3>
<pre><code class="solidity language-solidity">modifier onlyActive(address pool, uint256 invoiceId)</code></pre>
<p>Modifier that allows manipulation with an existing invoice only if it has the "Active" status.</p>
<h3 id="constructor">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<p>Contract constructor.</p>
<p><em>This contract uses OpenZeppelin upgrades and has no need for a constructor function.
The constructor is replaced with an initializer function.
This method disables the initializer feature of the OpenZeppelin upgrades plugin, preventing the initializer methods from being misused.</em></p>
<h3 id="initialize-1">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(contract IRegistry registry_) external</code></pre>
<p>Contract initializer</p>
<p><em>This method replaces the constructor for upgradeable contracts. It also sets the registry contract address in the contract's storage.</em></p>
<h4 id="parameters-10">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>registry_</td>
<td>contract IRegistry</td>
<td>Protocol registry address</td>
</tr>
</tbody>
</table>
<h3 id="payinvoice">payInvoice</h3>
<pre><code class="solidity language-solidity">function payInvoice(address pool, uint256 invoiceId) external payable</code></pre>
<p>On-chain payment of an invoice (trustless scenario)</p>
<p><em>In addition to the specified modifiers, there is also a check for the payer's wallet to be included in the whitelist of invoice payers.
To allow the invoice to be paid by any wallet, the whitelist field should be left empty when creating the invoice.
After successful payment, the invoice receives an irreversible "Paid" status.</em></p>
<h4 id="parameters-11">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the pool contract that issued the invoice</td>
</tr>
<tr>
<td>invoiceId</td>
<td>uint256</td>
<td>Identifier of the invoice being paid</td>
</tr>
</tbody>
</table>
<h3 id="createinvoice">createInvoice</h3>
<pre><code class="solidity language-solidity">function createInvoice(address pool, struct IInvoice.InvoiceCore core) external</code></pre>
<p>Create an invoice by a specified pool</p>
<p><em>The onlyValidInvoiceManager modifier determines which accounts can create an invoice for the specified pool.
After creation, the invoice receives an "Active" status.</em></p>
<h4 id="parameters-12">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the pool contract that issues the invoice</td>
</tr>
<tr>
<td>core</td>
<td>struct IInvoice.InvoiceCore</td>
<td>Invoice payment data (described in the interface)</td>
</tr>
</tbody>
</table>
<h3 id="cancelinvoice">cancelInvoice</h3>
<pre><code class="solidity language-solidity">function cancelInvoice(address pool, uint256 invoiceId) external</code></pre>
<p>Cancel an invoice</p>
<p><em>To cancel an invoice, the request must pass the onlyValidInvoiceManager modifier, which regulates who can manipulate the pool's invoices on behalf of the pool.
After cancellation, the invoice receives an irreversible "Canceled" status.</em></p>
<h4 id="parameters-13">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the pool contract that issued the invoice</td>
</tr>
<tr>
<td>invoiceId</td>
<td>uint256</td>
<td>Invoice identifier</td>
</tr>
</tbody>
</table>
<h3 id="setinvoicepaid">setInvoicePaid</h3>
<pre><code class="solidity language-solidity">function setInvoicePaid(address pool, uint256 invoiceId) external</code></pre>
<p>Off-chain payment of an invoice (trusted scenario)</p>
<p><em>Addresses that have the "SERVICE_MANAGER" role in the Service contract can change the status of any active invoice of any pool to "Paid", indicating a successful payment of the invoice through an off-chain payment method.
After successful payment, the invoice receives an irreversible "Paid" status.</em></p>
<h4 id="parameters-14">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the pool contract that issued the invoice</td>
</tr>
<tr>
<td>invoiceId</td>
<td>uint256</td>
<td>Invoice identifier</td>
</tr>
</tbody>
</table>
<h3 id="setinvoicecanceled">setInvoiceCanceled</h3>
<pre><code class="solidity language-solidity">function setInvoiceCanceled(address pool, uint256 invoiceId) external</code></pre>
<p>Canceling an invoice by the manager</p>
<p><em>Addresses that have the "SERVICE_MANAGER" role in the Service contract can cancel any active invoice of any pool.
After cancellation, the invoice receives an irreversible "Canceled" status.</em></p>
<h4 id="parameters-15">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the pool contract that issued the invoice</td>
</tr>
<tr>
<td>invoiceId</td>
<td>uint256</td>
<td>Invoice identifier</td>
</tr>
</tbody>
</table>
<h3 id="validateinvoicecore">validateInvoiceCore</h3>
<pre><code class="solidity language-solidity">function validateInvoiceCore(struct IInvoice.InvoiceCore core) public view returns (bool)</code></pre>
<p>This method checks the validity of invoice data during its creation</p>
<p><em>An invoice is considered valid if it meets the following criteria:
    - Non-zero payment amount (in any token, including the native network coin)
    - The expiration block has not yet been reached
    - The specified token for payment is a valid ERC20 contract</em></p>
<h4 id="parameters-16">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>core</td>
<td>struct IInvoice.InvoiceCore</td>
<td>Invoice data represented by the structure described in the InvoiceCore interface</td>
</tr>
</tbody>
</table>
<h4 id="return-values-6">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>True if the parameters are valid (reverts otherwise)</td>
</tr>
</tbody>
</table>
<h3 id="invoicestate">invoiceState</h3>
<pre><code class="solidity language-solidity">function invoiceState(address pool, uint256 invoiceId) public view returns (enum IInvoice.InvoiceState)</code></pre>
<p><em>This method returns the state of an invoice</em></p>
<h4 id="parameters-17">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>The address of the pool contract that issued the invoice</td>
</tr>
<tr>
<td>invoiceId</td>
<td>uint256</td>
<td>The identifier of the invoice</td>
</tr>
</tbody>
</table>
<h3 id="isvalidinvoicemanager">isValidInvoiceManager</h3>
<pre><code class="solidity language-solidity">function isValidInvoiceManager(address pool, address account) public view returns (bool)</code></pre>
<p>This method checks the account's authority to manipulate pool invoices</p>
<p><em>In order to create and cancel pool invoices, the account address must:
    - be listed in the pool's secretaries OR
    - have the "SERVICE_MANAGER" role in the Service contract OR
    - be the owner of the pool if the pool has not yet obtained DAO status</em></p>
<h4 id="parameters-18">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>The address of the pool contract</td>
</tr>
<tr>
<td>account</td>
<td>address</td>
<td>The account address</td>
</tr>
</tbody>
</table>
<h3 id="_setinvoicepaid">_setInvoicePaid</h3>
<pre><code class="solidity language-solidity">function _setInvoicePaid(address pool, uint256 invoiceId) private</code></pre>
<p><em>Implementation of the function that changes the status of an active invoice to "Paid"</em></p>
<h3 id="_setinvoicecanceled">_setInvoiceCanceled</h3>
<pre><code class="solidity language-solidity">function _setInvoiceCanceled(address pool, uint256 invoiceId) private</code></pre>
<p><em>Implementation of the function that cancels an active invoice and sets its status to "Canceled"</em></p>
<h2 id="pool">Pool</h2>
<p>These contracts are instances of on-chain implementations of user companies. The shareholders of the companies work with them, their addresses are used in the Registry contract as tags that allow obtaining additional legal information (before the purchase of the company by the client). They store legal data (after the purchase of the company by the client). Among other things, the contract is also the owner of the Token and TGE contracts.</p>
<p><em>There can be an unlimited number of such contracts, including for one company owner. The contract can be in three states:
1) the company was created by the administrator, a record of it is stored in the Registry, but the contract has not yet been deployed and does not have an owner (buyer) 
2) the contract is deployed, the company has an owner, but there is not yet a successful (softcap primary TGE), in this state its owner has the exclusive right to recreate the TGE in case of their failure (only one TGE can be launched at the same time) 
3) the primary TGE ended successfully, softcap is assembled - the company has received the status of DAO.    The owner no longer has any exclusive rights, all the actions of the company are carried out through the creation and execution of propousals after voting. In this status, the contract is also a treasury - it stores the company's values in the form of ETH and/or ERC20 tokens.
The "Pool owner" status is temporary and is assigned to the address that has successfully purchased a company and in which there has not been a single successful TGE Governance Token. The current owner's address of the company can be obtained by referring to the owner method of the Pool contract. If the isDAO method of the same contract returns "true", then this status does not grant any privileges or exclusive rights and has more of a historical and reference nature.
    As long as the pool is not considered a DAO, the address which is having this status can interact with such methods:
    - TGEFactory.sol:createPrimaryTGE(address poolAddress, IToken.TokenInfo memory tokenInfo, ITGE.TGEInfo memory tgeInfo, string memory metadataURI, IGovernanceSettings.NewGovernanceSettings memory governanceSettings</em>, address[] memory addSecretary, address[] memory addExecutor) - this method allows you to create a Governance Token compatible with ERC20, with a full set of standard settings, launch a primary TGE for it by deploying the corresponding contract, and also fully configure Governance using the NewGovernanceSettings structure and arrays of addSecretary and addExecutor addresses. The rules set for Governance will become relevant immediately after the successful completion of this primary TGE.<br />
    - Pool.sol:transferByOwner(address to, uint256 amount, address unitOfAccount) - this method allows you to withdraw ETH or any ERC20 token from the pool contract to any address specified by the owner<br />
    Moreover, while in this status, the pool owner, who has not yet become a DAO, can create invoices without restrictions using the Invoice:createInvoice(address pool, InvoiceCore memory core) method.<br />
    In case of a primary TGE failure, the company owner continues to use their unique status, which means they can recreate the token, TGE, and set new Governance settings within a single transaction._</p>
<h3 id="trademark">trademark</h3>
<pre><code class="solidity language-solidity">string trademark</code></pre>
<p><em>The company's trade mark, label, brand name. It also acts as the Name of all the Governance tokens created for this pool.</em></p>
<h3 id="companyinfo">companyInfo</h3>
<pre><code class="solidity language-solidity">struct ICompaniesRegistry.CompanyInfo companyInfo</code></pre>
<p><em>When a buyer acquires a company, its record disappears from the Registry contract, but before that, the company's legal data is copied to this variable.</em></p>
<h3 id="tokens">tokens</h3>
<pre><code class="solidity language-solidity">mapping(enum IToken.TokenType =&gt; address) tokens</code></pre>
<p><em>Mapping for Governance Token. There can be only one valid Governance token.</em></p>
<h3 id="lastproposalidforaddress">lastProposalIdForAddress</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; uint256) lastProposalIdForAddress</code></pre>
<p><em>last proposal id for address. This method returns the proposal Id for the last proposal created by the specified address.</em></p>
<h3 id="proposalcreatedat">proposalCreatedAt</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; uint256) proposalCreatedAt</code></pre>
<p><em>Mapping that stores the blocks of proposal creation for this pool. The main information about the proposal is stored in variables provided by the Governor.sol contract, which is inherited by this contract.</em></p>
<h3 id="tokensfulllist">tokensFullList</h3>
<pre><code class="solidity language-solidity">mapping(enum IToken.TokenType =&gt; address[]) tokensFullList</code></pre>
<p><em>A list of tokens belonging to this pool. There can be only one valid Governance token and several Preference tokens with different settings. The mapping key is the token type (token type encoding is specified in the IToken.sol interface). The value is an array of token identifiers.</em></p>
<h3 id="tokentypebyaddress">tokenTypeByAddress</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; enum IToken.TokenType) tokenTypeByAddress</code></pre>
<p><em>Mapping that stores information about the type of each token. The mapping key is the address of the token contract, and the value is the digital code of the token type.</em></p>
<h3 id="poolsecretary">poolSecretary</h3>
<pre><code class="solidity language-solidity">struct EnumerableSetUpgradeable.AddressSet poolSecretary</code></pre>
<p>This collection of addresses is part of the simplified role model of the pool and stores the addresses of accounts that have been assigned the role of pool secretary.</p>
<p><em>Pool secretary is an internal pool role with responsibilities that include working with invoices and creating proposals. This role serves to give authority, similar to a shareholder, to an account that does not have Governance Tokens (e.g., a hired employee).</em></p>
<h3 id="lastexecutedproposalid">lastExecutedProposalId</h3>
<pre><code class="solidity language-solidity">uint256 lastExecutedProposalId</code></pre>
<p><em>Identifier of the last executed proposal</em></p>
<h3 id="proposalidtotge">proposalIdToTGE</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; address) proposalIdToTGE</code></pre>
<p><em>Mapping that stores the addresses of TGE contracts that have been deployed as part of proposal execution, using the identifiers of those proposals as keys.</em></p>
<h3 id="poolexecutor">poolExecutor</h3>
<pre><code class="solidity language-solidity">struct EnumerableSetUpgradeable.AddressSet poolExecutor</code></pre>
<p>This collection of addresses is part of the simplified role model of the pool and stores the addresses of accounts that have been assigned the role of pool executor.</p>
<p><em>Pool Executor is an internal pool role with responsibilities that include executing proposals that have ended with a "for" decision in voting and have completed their time in the delayed state.</em></p>
<h3 id="oaurl">OAurl</h3>
<pre><code class="solidity language-solidity">string OAurl</code></pre>
<p><em>Operating Agreement Url</em></p>
<h3 id="onlyservice-1">onlyService</h3>
<pre><code class="solidity language-solidity">modifier onlyService()</code></pre>
<p>Modifier that allows the method to be called only by the Service contract.</p>
<p><em>It is used to transfer control of the Registry and deployable user contracts for the final configuration of the company.</em></p>
<h3 id="onlytgefactory">onlyTGEFactory</h3>
<pre><code class="solidity language-solidity">modifier onlyTGEFactory()</code></pre>
<p>Modifier that allows the method to be called only by the TGEFactory contract.</p>
<p><em>Used during TGE creation, where the TGEFactory contract deploys contracts and informs their addresses to the pool contract for storage.</em></p>
<h3 id="onlyserviceadmin">onlyServiceAdmin</h3>
<pre><code class="solidity language-solidity">modifier onlyServiceAdmin()</code></pre>
<p>Modifier that allows the method to be called only by an account that has the ADMIN role in the Service contract.</p>
<h3 id="constructor-1">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<h3 id="initialize-2">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(struct ICompaniesRegistry.CompanyInfo companyInfo_) external</code></pre>
<p><em>Initialization of a new pool and placement of user settings and data (including legal ones) in it</em></p>
<h4 id="parameters-19">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>companyInfo_</td>
<td>struct ICompaniesRegistry.CompanyInfo</td>
<td>Legal company data</td>
</tr>
</tbody>
</table>
<h3 id="setnewownerwithsettings">setNewOwnerWithSettings</h3>
<pre><code class="solidity language-solidity">function setNewOwnerWithSettings(address newowner, string trademark_, struct IGovernanceSettings.NewGovernanceSettings governanceSettings_) external</code></pre>
<p>Actions after purchasing a pool (including ownership transfer and governance settings)</p>
<p><em>This is executed only during a successful execution of purchasePool in the Service contract. The address that is mentioned in the 'newowner' field of the transaction calldata becomes the pool owner.
An internal pool role, relevant from the moment of purchasing a company until the first successful TGE. The sole and unchangeable wallet possessing this role is the account that paid the fee for creating the company. Once the pool becomes a DAO, this role no longer has any exclusive powers.
    The appointment of the Owner's address is done within the call to Pool.sol:setNewOwnerWithSettings(address newowner, string memory trademark</em>, NewGovernanceSettings memory governanceSettings_), which occurs when a new owner purchases the company._</p>
<h4 id="parameters-20">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>newowner</td>
<td>address</td>
<td>Address of the new contract owner account</td>
</tr>
<tr>
<td>trademark_</td>
<td>string</td>
<td>Company trademark</td>
</tr>
<tr>
<td>governanceSettings_</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>Governance settings (voting rules, etc.)</td>
</tr>
</tbody>
</table>
<h3 id="setsettings">setSettings</h3>
<pre><code class="solidity language-solidity">function setSettings(struct IGovernanceSettings.NewGovernanceSettings governanceSettings_, address[] secretary, address[] executor) external</code></pre>
<p>Changing the governance settings of the pool as a result of voting or the owner's initial pool setup</p>
<p>_This method can be called in one of two cases:</p>
<ul>
<li>The pool has attained DAO status, and a proposal including a transaction calling this method has been executed</li>
<li>The pool has not yet attained DAO status, and the pool owner initiates the initial TGE with new governance settings as arguments_</li>
</ul>
<h4 id="parameters-21">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>governanceSettings_</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>Governance settings</td>
</tr>
<tr>
<td>secretary</td>
<td>address[]</td>
<td>List of secretary addresses</td>
</tr>
<tr>
<td>executor</td>
<td>address[]</td>
<td>List of executor addresses</td>
</tr>
</tbody>
</table>
<h3 id="setcompanyinfo">setCompanyInfo</h3>
<pre><code class="solidity language-solidity">function setCompanyInfo(uint256 _jurisdiction, uint256 _entityType, string _ein, string _dateOfIncorporation, string _OAuri) external</code></pre>
<p>Setting legal data for the corresponding company pool</p>
<p><em>This method is executed as part of the internal transaction in the setCompanyInfoForPool method of the Registry contract</em></p>
<h4 id="parameters-22">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_jurisdiction</td>
<td>uint256</td>
<td>Digital code of the jurisdiction</td>
</tr>
<tr>
<td>_entityType</td>
<td>uint256</td>
<td>Digital code of the organization type</td>
</tr>
<tr>
<td>_ein</td>
<td>string</td>
<td>Government registration number of the company</td>
</tr>
<tr>
<td>_dateOfIncorporation</td>
<td>string</td>
<td>Date of incorporation of the company</td>
</tr>
<tr>
<td>_OAuri</td>
<td>string</td>
<td>Operating Agreement URL</td>
</tr>
</tbody>
</table>
<h3 id="receive">receive</h3>
<pre><code class="solidity language-solidity">receive() external payable</code></pre>
<p><em>Method for receiving an Ethereum contract that issues an event.</em></p>
<h3 id="castvote">castVote</h3>
<pre><code class="solidity language-solidity">function castVote(uint256 proposalId, bool support) external</code></pre>
<p>Method for voting "for" or "against" a given proposal</p>
<p><em>This method calls the _castVote function defined in the Governor.sol contract.
Since proposals in the CompanyDAO protocol can be prematurely finalized, after each successful invocation of this method, a check is performed for the occurrence of such conditions.</em></p>
<h4 id="parameters-23">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Pool proposal ID</td>
</tr>
<tr>
<td>support</td>
<td>bool</td>
<td>"True" for voting "for", "False" for voting "against"</td>
</tr>
</tbody>
</table>
<h3 id="settoken">setToken</h3>
<pre><code class="solidity language-solidity">function setToken(address token_, enum IToken.TokenType tokenType_) external</code></pre>
<p><em>Adding a new entry about the deployed token contract to the list of tokens related to the pool.</em></p>
<h4 id="parameters-24">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>token_</td>
<td>address</td>
<td>Token address</td>
</tr>
<tr>
<td>tokenType_</td>
<td>enum IToken.TokenType</td>
<td>Token type</td>
</tr>
</tbody>
</table>
<h3 id="setproposalidtotge">setProposalIdToTGE</h3>
<pre><code class="solidity language-solidity">function setProposalIdToTGE(address tge) external</code></pre>
<p><em>This method adds a record to the proposalIdToTGE mapping indicating that a TGE contract with the specified address was deployed as a result of executing the proposal with the lastExecutedProposalId identifier.</em></p>
<h4 id="parameters-25">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE address</td>
</tr>
</tbody>
</table>
<h3 id="executeproposal">executeProposal</h3>
<pre><code class="solidity language-solidity">function executeProposal(uint256 proposalId) external</code></pre>
<p>This method is used to initiate the execution of a proposal.</p>
<p><em>For this method to work, the following conditions must be met:
    - The transaction sender must be a valid executor (more details in the isValidExecutor function)
    - The proposal must have the "Awaiting Execution" status.</em></p>
<h4 id="parameters-26">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="cancelproposal">cancelProposal</h3>
<pre><code class="solidity language-solidity">function cancelProposal(uint256 proposalId) external</code></pre>
<p>Method for emergency cancellation of a proposal.</p>
<p><em>Cancel a proposal, callable only by the Service contract.</em></p>
<h4 id="parameters-27">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="propose">propose</h3>
<pre><code class="solidity language-solidity">function propose(address proposer, uint256 proposeType, struct IGovernor.ProposalCoreData core, struct IGovernor.ProposalMetaData meta) external returns (uint256 proposalId)</code></pre>
<p><em>Creating a proposal and assigning it a unique identifier to store in the list of proposals in the Governor contract.</em></p>
<h4 id="parameters-28">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposer</td>
<td>address</td>
<td></td>
</tr>
<tr>
<td>proposeType</td>
<td>uint256</td>
<td></td>
</tr>
<tr>
<td>core</td>
<td>struct IGovernor.ProposalCoreData</td>
<td>Proposal core data</td>
</tr>
<tr>
<td>meta</td>
<td>struct IGovernor.ProposalMetaData</td>
<td>Proposal meta data</td>
</tr>
</tbody>
</table>
<h3 id="transferbyowner">transferByOwner</h3>
<pre><code class="solidity language-solidity">function transferByOwner(address to, uint256 amount, address unitOfAccount) external</code></pre>
<p>Transfers funds from the pool's account to a specified address.</p>
<p><em>This method can only be called by the pool owner and only during the period before the pool becomes a DAO.</em></p>
<h4 id="parameters-29">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td>address</td>
<td>The recipient's address</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The transfer amount</td>
</tr>
<tr>
<td>unitOfAccount</td>
<td>address</td>
<td>The unit of account (token contract address or address(0) for ETH)</td>
</tr>
</tbody>
</table>
<h3 id="customtxbyowner">customTxByOwner</h3>
<pre><code class="solidity language-solidity">function customTxByOwner(address target, uint256 value, bytes data) external</code></pre>
<p><em>Execute custom tx if the pool is not yet a  DAO</em></p>
<h4 id="parameters-30">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>address</td>
<td>receiver addresss</td>
</tr>
<tr>
<td>value</td>
<td>uint256</td>
<td>transfer amount</td>
</tr>
<tr>
<td>data</td>
<td>bytes</td>
<td>input data of the transaction</td>
</tr>
</tbody>
</table>
<h3 id="isdao">isDAO</h3>
<pre><code class="solidity language-solidity">function isDAO() public view returns (bool)</code></pre>
<p><em>Checks if the pool has achieved DAO status.
A pool achieves DAO status if it has a valid governance token and the primary TGE was successful.</em></p>
<h4 id="return-values-7">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>isDao True if the pool is a DAO, false otherwise.</td>
</tr>
</tbody>
</table>
<h3 id="owner">owner</h3>
<pre><code class="solidity language-solidity">function owner() public view returns (address)</code></pre>
<p><em>Returns the owner of the pool.</em></p>
<h4 id="return-values-8">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address</td>
<td>The address of the pool owner.</td>
</tr>
</tbody>
</table>
<h3 id="gettokens">getTokens</h3>
<pre><code class="solidity language-solidity">function getTokens(enum IToken.TokenType tokenType) external view returns (address[])</code></pre>
<p><em>Returns the list of tokens associated with the pool based on the token type.</em></p>
<h4 id="parameters-31">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenType</td>
<td>enum IToken.TokenType</td>
<td>The type of tokens to retrieve.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-9">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address[]</td>
<td>The array of token addresses.</td>
</tr>
</tbody>
</table>
<h3 id="getgovernancetoken">getGovernanceToken</h3>
<pre><code class="solidity language-solidity">function getGovernanceToken() public view returns (contract IToken)</code></pre>
<p><em>Returns the governance token associated with the pool.</em></p>
<h4 id="return-values-10">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>contract IToken</td>
<td>The governance token address.</td>
</tr>
</tbody>
</table>
<h3 id="tokenexists">tokenExists</h3>
<pre><code class="solidity language-solidity">function tokenExists(contract IToken token) public view returns (bool)</code></pre>
<p><em>Checks if a token exists in the pool.</em></p>
<h4 id="parameters-32">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>token</td>
<td>contract IToken</td>
<td>The token to check.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-11">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>True if the token exists, false otherwise.</td>
</tr>
</tbody>
</table>
<h3 id="getpoolsecretary">getPoolSecretary</h3>
<pre><code class="solidity language-solidity">function getPoolSecretary() external view returns (address[])</code></pre>
<p><em>Returns the list of pool secretaries.</em></p>
<h4 id="return-values-12">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address[]</td>
<td>The array of pool secretary addresses.</td>
</tr>
</tbody>
</table>
<h3 id="getpoolexecutor">getPoolExecutor</h3>
<pre><code class="solidity language-solidity">function getPoolExecutor() external view returns (address[])</code></pre>
<p><em>Returns the list of pool executors.</em></p>
<h4 id="return-values-13">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address[]</td>
<td>The array of pool executor addresses.</td>
</tr>
</tbody>
</table>
<h3 id="ispoolsecretary">isPoolSecretary</h3>
<pre><code class="solidity language-solidity">function isPoolSecretary(address account) public view returns (bool)</code></pre>
<p><em>Checks if an address is a pool secretary.</em></p>
<h4 id="parameters-33">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The address to check.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-14">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>True if the address is a pool secretary, false otherwise.</td>
</tr>
</tbody>
</table>
<h3 id="ispoolexecutor">isPoolExecutor</h3>
<pre><code class="solidity language-solidity">function isPoolExecutor(address account) public view returns (bool)</code></pre>
<p><em>Checks if an address is a pool executor.</em></p>
<h4 id="parameters-34">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The address to check.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-15">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>True if the address is a pool executor, false otherwise.</td>
</tr>
</tbody>
</table>
<h3 id="isvalidproposer">isValidProposer</h3>
<pre><code class="solidity language-solidity">function isValidProposer(address account) public view returns (bool)</code></pre>
<p><em>Checks if an address is a valid proposer for creating proposals.</em></p>
<h4 id="parameters-35">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The address to check.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-16">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>True if the address is a valid proposer, false otherwise.</td>
</tr>
</tbody>
</table>
<h3 id="isvalidexecutor">isValidExecutor</h3>
<pre><code class="solidity language-solidity">function isValidExecutor(address account) public view returns (bool)</code></pre>
<p><em>Checks if an address is a valid executor for executing ballot proposals.</em></p>
<h4 id="parameters-36">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The address to check.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-17">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>True if the address is a valid executor, false otherwise.</td>
</tr>
</tbody>
</table>
<h3 id="islastproposalidbytypeactive">isLastProposalIdByTypeActive</h3>
<pre><code class="solidity language-solidity">function isLastProposalIdByTypeActive(uint256 type_) public view returns (bool)</code></pre>
<p><em>Checks if the last proposal of a specific type is active.</em></p>
<h4 id="parameters-37">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>type_</td>
<td>uint256</td>
<td>The type of proposal.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-18">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>True if the last proposal of the given type is active, false otherwise.</td>
</tr>
</tbody>
</table>
<h3 id="validategovernancesettings">validateGovernanceSettings</h3>
<pre><code class="solidity language-solidity">function validateGovernanceSettings(struct IGovernanceSettings.NewGovernanceSettings settings) external pure</code></pre>
<p><em>Validates the governance settings for creating proposals.</em></p>
<h4 id="parameters-38">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>settings</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>The governance settings to validate.</td>
</tr>
</tbody>
</table>
<h3 id="availablevotesforproposal">availableVotesForProposal</h3>
<pre><code class="solidity language-solidity">function availableVotesForProposal(uint256 proposalId) external view returns (uint256)</code></pre>
<p><em>Returns the available votes for a proposal at the current block.</em></p>
<h4 id="parameters-39">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>The ID of the proposal.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-19">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The available votes for the proposal.</td>
</tr>
</tbody>
</table>
<h3 id="_afterproposalcreated">_afterProposalCreated</h3>
<pre><code class="solidity language-solidity">function _afterProposalCreated(uint256 proposalId) internal</code></pre>
<p><em>Internal function to be called after a proposal is created.</em></p>
<h4 id="parameters-40">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>The ID of the created proposal.</td>
</tr>
</tbody>
</table>
<h3 id="_getcurrentvotes">_getCurrentVotes</h3>
<pre><code class="solidity language-solidity">function _getCurrentVotes(address account) internal view returns (uint256)</code></pre>
<p><em>Internal function to get the current votes of an account.</em></p>
<h4 id="parameters-41">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The account's address.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-20">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The current votes of the account.</td>
</tr>
</tbody>
</table>
<h3 id="_getblocktotalvotes">_getBlockTotalVotes</h3>
<pre><code class="solidity language-solidity">function _getBlockTotalVotes(uint256 blocknumber) internal view returns (uint256)</code></pre>
<p><em>Internal function to get the total votes in the pool at a specific block.</em></p>
<h4 id="parameters-42">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>blocknumber</td>
<td>uint256</td>
<td>The block number.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-21">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The total votes at the given block.</td>
</tr>
</tbody>
</table>
<h3 id="_getpastvotes">_getPastVotes</h3>
<pre><code class="solidity language-solidity">function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256)</code></pre>
<p><em>Internal function to get the past votes of an account at a specific block.</em></p>
<h4 id="parameters-43">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The account's address.</td>
</tr>
<tr>
<td>blockNumber</td>
<td>uint256</td>
<td>The block number.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-22">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The past votes of the account at the given block.</td>
</tr>
</tbody>
</table>
<h3 id="_setlastproposalidforaddress">_setLastProposalIdForAddress</h3>
<pre><code class="solidity language-solidity">function _setLastProposalIdForAddress(address proposer, uint256 proposalId) internal</code></pre>
<p><em>Internal function to set the last proposal ID for an address.</em></p>
<h4 id="parameters-44">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposer</td>
<td>address</td>
<td>The proposer's address.</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>The proposal ID.</td>
</tr>
</tbody>
</table>
<h2 id="registry-1">Registry</h2>
<p>This contract serves as a registry to store all events, contracts, and proposals of all pools using global sequential numbering.</p>
<p><em>The repository of all user and business entities created by the protocol: companies to be implemented, contracts to be deployed, proposals created by shareholders. The main logic of the registry is implemented in contracts that inherit from Registry.</em></p>
<h3 id="globalproposalids">globalProposalIds</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; mapping(uint256 =&gt; uint256)) globalProposalIds</code></pre>
<p><em>This mapping stores the correspondence between the pool address, the local proposal number, and its global number registered in the registry.</em></p>
<h3 id="log">Log</h3>
<pre><code class="solidity language-solidity">event Log(address sender, address receiver, uint256 value, bytes data)</code></pre>
<h3 id="constructor-2">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<p>Contract constructor.</p>
<p><em>This contract uses OpenZeppelin upgrades and has no need for a constructor function.
The constructor is replaced with an initializer function.
This method disables the initializer feature of the OpenZeppelin upgrades plugin, preventing the initializer methods from being misused.</em></p>
<h3 id="initialize-3">initialize</h3>
<pre><code class="solidity language-solidity">function initialize() public</code></pre>
<p>Contract initializer</p>
<p><em>This method replaces the constructor for upgradeable contracts.</em></p>
<h3 id="setglobalproposalid">setGlobalProposalId</h3>
<pre><code class="solidity language-solidity">function setGlobalProposalId(address pool, uint256 proposalId, uint256 globalProposalId) internal</code></pre>
<p><em>Update global proposal ID</em></p>
<h4 id="parameters-45">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Local Proposal ID</td>
</tr>
<tr>
<td>globalProposalId</td>
<td>uint256</td>
<td>Global Proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="getglobalproposalid">getGlobalProposalId</h3>
<pre><code class="solidity language-solidity">function getGlobalProposalId(address pool, uint256 proposalId) public view returns (uint256)</code></pre>
<p><em>Return global proposal ID</em></p>
<h4 id="parameters-46">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h4 id="return-values-23">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>Global proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="log-1">log</h3>
<pre><code class="solidity language-solidity">function log(address sender, address receiver, uint256 value, bytes data) external</code></pre>
<h2 id="service-1">Service</h2>
<p>The main contract of the protocol, the starting point of interaction for new clients.</p>
<p><em>This contract deploys the core OZ Access Control model, where the distribution of accounts determines the behavior of most modifiers.
The address of this contract is specified in all other contracts, and this contract also stores the addresses of those contracts. The mutual references between contracts implement a system of "own-foreign" recognition.
This contract is responsible for updating itself and all other protocol contracts, including user contracts.</em></p>
<h3 id="denom">DENOM</h3>
<pre><code class="solidity language-solidity">uint256 DENOM</code></pre>
<p>Denominator for shares (such as thresholds)</p>
<p><em>The constant Service.sol:DENOM is used to work with percentage values of QuorumThreshold and DecisionThreshold thresholds, as well as for calculating the ProtocolTokenFee. In this version, it is equal to 1,000,000, for clarity stored as 100 * 10 ^ 4.
    10^4 corresponds to one percent, and 100 * 10^4 corresponds to one hundred percent.
    The value of 12.3456% will be written as 123,456, and 78.9% as 789,000.
    This notation allows specifying ratios with an accuracy of up to four decimal places in percentage notation (six decimal places in decimal notation).
    When working with the CompanyDAO frontend, the application scripts automatically convert the familiar percentage notation into the required format. When using the contracts independently, this feature of value notation should be taken into account.</em></p>
<h3 id="admin_role">ADMIN_ROLE</h3>
<pre><code class="solidity language-solidity">bytes32 ADMIN_ROLE</code></pre>
<p>Hash code of the ADMIN role for the OZ Access Control model</p>
<p><em>The main role of the entire ecosystem, the protocol owner. The address assigned to this role can perform all actions related to updating contract implementations or interacting with or configuring the protocol's Treasury. The administrator can cancel suspicious proposals awaiting execution, pause the operation of protocol contracts and pools. In addition, the administrator can perform all actions provided for the SERVICE_MANAGER role.
    The holder of this role can assign the roles of ADMIN, WHITELISTED_USER, and SERVICE_MANAGER to other accounts.
    Storage, assignment, and revocation of the role are carried out using the standard methods of the AccessControl model from OpenZeppelin: grantRole, revokeRole, setRole.</em></p>
<h3 id="service_manager_role">SERVICE_MANAGER_ROLE</h3>
<pre><code class="solidity language-solidity">bytes32 SERVICE_MANAGER_ROLE</code></pre>
<p>Hash code of the MANAGER role for the OZ Access Control model</p>
<p><em>The administrator can delegate some of their powers to the owners of addresses assigned the SERVICE_MANAGER role. The administrator can also perform all the methods listed below. This role is assigned and removed by the administrator and was created for assigning addresses managed by worker scripts (automatic backend modules whose task is to constantly track changes in the states of all ecosystem components and initiate transactions that make actual changes and involve necessary scenarios for certain contracts at the moment).
    In addition, the holder of this role has the same powers as the holders of the Secretary and Executor roles in any pool, assigned by its shareholders.
    The holder of this role can assign the WHITELISTED_USER role to other accounts.
    Storage, assignment, and revocation of the role are carried out using the standard methods of the AccessControl model from OpenZeppelin: grantRole, revokeRole, setRole.</em></p>
<h3 id="whitelisted_user_role">WHITELISTED_USER_ROLE</h3>
<pre><code class="solidity language-solidity">bytes32 WHITELISTED_USER_ROLE</code></pre>
<p>Legacy hash code of users added to the whitelist. Currently unused role.</p>
<h3 id="executor_role">EXECUTOR_ROLE</h3>
<pre><code class="solidity language-solidity">bytes32 EXECUTOR_ROLE</code></pre>
<p>Hash code of the EXECUTOR role for the OZ Access Control model</p>
<h3 id="registry-2">registry</h3>
<pre><code class="solidity language-solidity">contract IRegistry registry</code></pre>
<p><em>Address of the Registry contract</em></p>
<h3 id="poolbeacon">poolBeacon</h3>
<pre><code class="solidity language-solidity">address poolBeacon</code></pre>
<p><em>Address of the Pool beacon contract</em></p>
<h3 id="tokenbeacon">tokenBeacon</h3>
<pre><code class="solidity language-solidity">address tokenBeacon</code></pre>
<p><em>Address of the Token beacon contract</em></p>
<h3 id="tgebeacon">tgeBeacon</h3>
<pre><code class="solidity language-solidity">address tgeBeacon</code></pre>
<p><em>Address of the TGE beacon contract</em></p>
<h3 id="protocoltreasury">protocolTreasury</h3>
<pre><code class="solidity language-solidity">address protocolTreasury</code></pre>
<p>Address to hold the commission from TGE in distributed tokens</p>
<p><em>0.1% (can be changed by the admin) of all Governance tokens from successful TGE are held here</em></p>
<h3 id="protocoltokenfee">protocolTokenFee</h3>
<pre><code class="solidity language-solidity">uint256 protocolTokenFee</code></pre>
<p>The fee size that the protocol charges in tokens from each successful TGE (only for Governance Tokens)</p>
<p><em>Protocol token fee percentage value with 4 decimals.
Examples: 1% = 10000, 100% = 1000000, 0.1% = 1000</em></p>
<h3 id="protolcollectedfee">protolCollectedFee</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; uint256) protolCollectedFee</code></pre>
<p>Total fees collected from TGE in Governance tokens for each pool</p>
<p><em>Protocol token fee claimed for tokens</em></p>
<h3 id="customproposal-1">customProposal</h3>
<pre><code class="solidity language-solidity">contract ICustomProposal customProposal</code></pre>
<p><em>Address of the Proposal beacon contract</em></p>
<h3 id="vesting">vesting</h3>
<pre><code class="solidity language-solidity">contract IVesting vesting</code></pre>
<p><em>Address of the Vesting contract</em></p>
<h3 id="invoice-1">invoice</h3>
<pre><code class="solidity language-solidity">contract IInvoice invoice</code></pre>
<p><em>Address of the Invoice contract</em></p>
<h3 id="tokenfactory">tokenFactory</h3>
<pre><code class="solidity language-solidity">contract ITokenFactory tokenFactory</code></pre>
<p><em>Address of the TokenFactory contract</em></p>
<h3 id="tgefactory">tgeFactory</h3>
<pre><code class="solidity language-solidity">contract ITGEFactory tgeFactory</code></pre>
<p><em>Address of the TGEFactory contract</em></p>
<h3 id="tokenerc1155beacon">tokenERC1155Beacon</h3>
<pre><code class="solidity language-solidity">address tokenERC1155Beacon</code></pre>
<p><em>Address of the Token beacon contract (for ERC1155 tokens)</em></p>
<h3 id="poolcreated">PoolCreated</h3>
<pre><code class="solidity language-solidity">event PoolCreated(address pool, address token, address tge)</code></pre>
<p><em>Event emitted upon deployment of a pool contract (i.e., creation of a pool)</em></p>
<h4 id="parameters-47">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the Pool contract</td>
</tr>
<tr>
<td>token</td>
<td>address</td>
<td>Address of the pool's token contract (usually 0, as the pool and token contracts are deployed separately)</td>
</tr>
<tr>
<td>tge</td>
<td>address</td>
<td>Address of the TGE contract (usually 0, as the pool and TGE contracts are deployed separately)</td>
</tr>
</tbody>
</table>
<h3 id="poolpurchased">PoolPurchased</h3>
<pre><code class="solidity language-solidity">event PoolPurchased(address pool, address token, address tge)</code></pre>
<p><em>Event emitted upon the purchase of a pool</em></p>
<h4 id="parameters-48">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the purchased pool</td>
</tr>
<tr>
<td>token</td>
<td>address</td>
<td>Address of the pool's token contract (usually 0, as the pool does not have any tokens at the time of purchase)</td>
</tr>
<tr>
<td>tge</td>
<td>address</td>
<td>Address of the TGE contract (usually 0)</td>
</tr>
</tbody>
</table>
<h3 id="protocoltreasurychanged">ProtocolTreasuryChanged</h3>
<pre><code class="solidity language-solidity">event ProtocolTreasuryChanged(address protocolTreasury)</code></pre>
<p><em>Event emitted when the balance of the Protocol Treasury changes due to transfers of pool tokens collected as protocol fees.</em></p>
<h4 id="parameters-49">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>protocolTreasury</td>
<td>address</td>
<td>Address of the Protocol Treasury</td>
</tr>
</tbody>
</table>
<h3 id="protocoltokenfeechanged">ProtocolTokenFeeChanged</h3>
<pre><code class="solidity language-solidity">event ProtocolTokenFeeChanged(uint256 protocolTokenFee)</code></pre>
<p><em>Event emitted when the protocol changes the token fee collected from pool tokens.</em></p>
<h4 id="parameters-50">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>protocolTokenFee</td>
<td>uint256</td>
<td>New protocol token fee</td>
</tr>
</tbody>
</table>
<h3 id="feestransferred">FeesTransferred</h3>
<pre><code class="solidity language-solidity">event FeesTransferred(address to, uint256 amount)</code></pre>
<p><em>Event emitted when the service fees are transferred to another address</em></p>
<h4 id="parameters-51">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td>address</td>
<td>Transfer recipient</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>Amount of ETH transferred</td>
</tr>
</tbody>
</table>
<h3 id="proposalcancelled">ProposalCancelled</h3>
<pre><code class="solidity language-solidity">event ProposalCancelled(address pool, uint256 proposalId)</code></pre>
<p><em>Event emitted when a proposal is canceled by an account with the Service Manager role</em></p>
<h4 id="parameters-52">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Pool local proposal id</td>
</tr>
</tbody>
</table>
<h3 id="poolbeaconchanged">PoolBeaconChanged</h3>
<pre><code class="solidity language-solidity">event PoolBeaconChanged(address beacon)</code></pre>
<p><em>Event emitted on PoolBeacon change.</em></p>
<h4 id="parameters-53">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beacon</td>
<td>address</td>
<td>Beacon address</td>
</tr>
</tbody>
</table>
<h3 id="tgebeaconchanged">TGEBeaconChanged</h3>
<pre><code class="solidity language-solidity">event TGEBeaconChanged(address beacon)</code></pre>
<p><em>Event emitted on TGEBeacon change.</em></p>
<h4 id="parameters-54">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beacon</td>
<td>address</td>
<td>Beacon address</td>
</tr>
</tbody>
</table>
<h3 id="tokenbeaconchanged">TokenBeaconChanged</h3>
<pre><code class="solidity language-solidity">event TokenBeaconChanged(address beacon)</code></pre>
<p><em>Event emitted on TokenBeacon change.</em></p>
<h4 id="parameters-55">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beacon</td>
<td>address</td>
<td>Beacon address</td>
</tr>
</tbody>
</table>
<h3 id="custompropsalchanged">CustomPropsalChanged</h3>
<pre><code class="solidity language-solidity">event CustomPropsalChanged(address proxy)</code></pre>
<p><em>Event emitted on CustomPropsalProxy change.</em></p>
<h4 id="parameters-56">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proxy</td>
<td>address</td>
<td>Proxy address</td>
</tr>
</tbody>
</table>
<h3 id="invoicechanged">InvoiceChanged</h3>
<pre><code class="solidity language-solidity">event InvoiceChanged(address proxy)</code></pre>
<p><em>Event emitted on InvoiceProxy change.</em></p>
<h4 id="parameters-57">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proxy</td>
<td>address</td>
<td>Proxy address</td>
</tr>
</tbody>
</table>
<h3 id="registrychanged">RegistryChanged</h3>
<pre><code class="solidity language-solidity">event RegistryChanged(address proxy)</code></pre>
<p><em>Event emitted on RegistryProxy change.</em></p>
<h4 id="parameters-58">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proxy</td>
<td>address</td>
<td>Proxy address</td>
</tr>
</tbody>
</table>
<h3 id="tgefactorychanged">TGEFactoryChanged</h3>
<pre><code class="solidity language-solidity">event TGEFactoryChanged(address proxy)</code></pre>
<p><em>Event emitted on TGEFactoryProxy change.</em></p>
<h4 id="parameters-59">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proxy</td>
<td>address</td>
<td>Proxy address</td>
</tr>
</tbody>
</table>
<h3 id="tokenfactorychanged">TokenFactoryChanged</h3>
<pre><code class="solidity language-solidity">event TokenFactoryChanged(address proxy)</code></pre>
<p><em>Event emitted on TokenFactoryProxy change.</em></p>
<h4 id="parameters-60">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proxy</td>
<td>address</td>
<td>Proxy address</td>
</tr>
</tbody>
</table>
<h3 id="vestingchanged">VestingChanged</h3>
<pre><code class="solidity language-solidity">event VestingChanged(address proxy)</code></pre>
<p><em>Event emitted on VestingProxy change.</em></p>
<h4 id="parameters-61">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proxy</td>
<td>address</td>
<td>Proxy address</td>
</tr>
</tbody>
</table>
<h3 id="onlypool">onlyPool</h3>
<pre><code class="solidity language-solidity">modifier onlyPool()</code></pre>
<p>Modifier that allows the method to be called only by the Pool contract.</p>
<h3 id="onlytge">onlyTGE</h3>
<pre><code class="solidity language-solidity">modifier onlyTGE()</code></pre>
<p>Modifier that allows the method to be called only by the TGE contract.</p>
<h3 id="onlyregistry">onlyRegistry</h3>
<pre><code class="solidity language-solidity">modifier onlyRegistry()</code></pre>
<p>Modifier that allows the method to be called only by the Registry contract.</p>
<h3 id="onlymanager-1">onlyManager</h3>
<pre><code class="solidity language-solidity">modifier onlyManager()</code></pre>
<p>Modifier that allows the method to be called only by an account with the ADMIN role in the Registry contract.</p>
<h3 id="constructor-3">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<p>Contract constructor.</p>
<p><em>This contract uses OpenZeppelin upgrades and has no need for a constructor function.
The constructor is replaced with an initializer function.
This method disables the initializer feature of the OpenZeppelin upgrades plugin, preventing the initializer methods from being misused.</em></p>
<h3 id="initialize-4">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(contract IRegistry registry_, contract ICustomProposal customProposal_, contract IVesting vesting_, address poolBeacon_, address tokenBeacon_, address tgeBeacon_, uint256 protocolTokenFee_) external</code></pre>
<p><em>Initializer function, can only be called once</em></p>
<h4 id="parameters-62">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>registry_</td>
<td>contract IRegistry</td>
<td>Registry address</td>
</tr>
<tr>
<td>customProposal_</td>
<td>contract ICustomProposal</td>
<td>Custom proposals address</td>
</tr>
<tr>
<td>vesting_</td>
<td>contract IVesting</td>
<td>Vesting address</td>
</tr>
<tr>
<td>poolBeacon_</td>
<td>address</td>
<td>Pool beacon</td>
</tr>
<tr>
<td>tokenBeacon_</td>
<td>address</td>
<td>Governance token beacon</td>
</tr>
<tr>
<td>tgeBeacon_</td>
<td>address</td>
<td>TGE beacon</td>
</tr>
<tr>
<td>protocolTokenFee_</td>
<td>uint256</td>
<td>Protocol token fee</td>
</tr>
</tbody>
</table>
<h3 id="purchasepool">purchasePool</h3>
<pre><code class="solidity language-solidity">function purchasePool(uint256 jurisdiction, uint256 entityType, string trademark, struct IGovernanceSettings.NewGovernanceSettings governanceSettings) external payable</code></pre>
<p>Method for purchasing a pool by the user. Among the data submitted for input, there are jurisdiction and Entity Type</p>
<p><em>The user refers to the Service protocol's purchasePool method, in which arguments indicate the digital jurisdiction code and the digital organizational type code of the company (as well as Governance settings provided by the NewGovernanceSettings interface, and a string record that will serve as the company's trademark). If there is at least one unoccupied and available company for purchase in the Registry contract (queue record with keys in the form of user-transmitted jurisdiction and organizational type codes), the following actions occur:
    -    reserving the company for the user (removing it from the list of available ones)
    -    debiting the commission in ETH (in fact, the company's price) from the user's balance, which is equal to the fee field in the CompanyInfo structure stored in the companies of the Registry contract
    -    making changes to the contract through an internal transaction using the setNewOwnerWithSettings method, which includes changing the company's trademark, its owner, and Governance settings.
    From this point on, the user is considered the Owner of the company.</em></p>
<h4 id="parameters-63">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>jurisdiction</td>
<td>uint256</td>
<td>Digital code of the jurisdiction.</td>
</tr>
<tr>
<td>entityType</td>
<td>uint256</td>
<td>Digital code of the entity type.</td>
</tr>
<tr>
<td>trademark</td>
<td>string</td>
<td>Company's trademark.</td>
</tr>
<tr>
<td>governanceSettings</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>Initial Governance settings.</td>
</tr>
</tbody>
</table>
<h3 id="transferpurchasedpoolbyservice">transferPurchasedPoolByService</h3>
<pre><code class="solidity language-solidity">function transferPurchasedPoolByService(address newowner, uint256 jurisdiction, uint256 entityType, string trademark, struct IGovernanceSettings.NewGovernanceSettings governanceSettings) external</code></pre>
<p>Method for manually transferring the company to a new owner.</p>
<p><em>This method can be used when paying for the company's cost (protocol fee) through any other means (off-chain payment).</em></p>
<h4 id="parameters-64">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>newowner</td>
<td>address</td>
<td></td>
</tr>
<tr>
<td>jurisdiction</td>
<td>uint256</td>
<td>Digital code of the jurisdiction.</td>
</tr>
<tr>
<td>entityType</td>
<td>uint256</td>
<td>Digital code of the entity type.</td>
</tr>
<tr>
<td>trademark</td>
<td>string</td>
<td>Company's trademark.</td>
</tr>
<tr>
<td>governanceSettings</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>Initial Governance settings.</td>
</tr>
</tbody>
</table>
<h3 id="addproposal">addProposal</h3>
<pre><code class="solidity language-solidity">function addProposal(uint256 proposalId) external</code></pre>
<p>Adding a new record of a proposal to the Registry.</p>
<p><em>To ensure the security and consistency of the contract architecture, user contracts do not directly interact with the Registry.
Due to the complexity of the role model for creating proposals, registering a new record is performed from the central contract.</em></p>
<h4 id="parameters-65">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID.</td>
</tr>
</tbody>
</table>
<h3 id="addevent">addEvent</h3>
<pre><code class="solidity language-solidity">function addEvent(enum IRecordsRegistry.EventType eventType, uint256 proposalId, string metaHash) external</code></pre>
<p>Adding a new record of an event to the Registry.</p>
<p><em>To ensure the security and consistency of the contract architecture, user contracts do not directly interact with the Registry.</em></p>
<h4 id="parameters-66">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>eventType</td>
<td>enum IRecordsRegistry.EventType</td>
<td>Event type.</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID.</td>
</tr>
<tr>
<td>metaHash</td>
<td>string</td>
<td>Hash value of event metadata.</td>
</tr>
</tbody>
</table>
<h3 id="addinvoiceevent">addInvoiceEvent</h3>
<pre><code class="solidity language-solidity">function addInvoiceEvent(address pool, uint256 invoiceId) external returns (uint256)</code></pre>
<h3 id="createpool">createPool</h3>
<pre><code class="solidity language-solidity">function createPool(struct ICompaniesRegistry.CompanyInfo companyInfo) external</code></pre>
<p>Method for deploying a pool contract.</p>
<p><em>When working with the Registry contract, the address that has the COMPANIES_MANAGER role in that contract can deploy the pool contract by sending a transaction with the company's legal data as an argument.</em></p>
<h4 id="parameters-67">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>companyInfo</td>
<td>struct ICompaniesRegistry.CompanyInfo</td>
<td>Company info.</td>
</tr>
</tbody>
</table>
<h3 id="transfercollectedfees">transferCollectedFees</h3>
<pre><code class="solidity language-solidity">function transferCollectedFees(address to) external</code></pre>
<p><em>Transfer the collected protocol fees obtained from the sale of pools to the specified address.</em></p>
<h4 id="parameters-68">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td>address</td>
<td>The transfer recipient.</td>
</tr>
</tbody>
</table>
<h3 id="setfactories">setFactories</h3>
<pre><code class="solidity language-solidity">function setFactories(contract ITokenFactory tokenFactory_, contract ITGEFactory tgeFactory_) external</code></pre>
<p><em>Sets factories for previously deployed service</em></p>
<h4 id="parameters-69">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenFactory_</td>
<td>contract ITokenFactory</td>
<td>TokenFactory address</td>
</tr>
<tr>
<td>tgeFactory_</td>
<td>contract ITGEFactory</td>
<td>TGEFactory address</td>
</tr>
</tbody>
</table>
<h3 id="setprotocolcollectedfee">setProtocolCollectedFee</h3>
<pre><code class="solidity language-solidity">function setProtocolCollectedFee(address _token, uint256 _protocolTokenFee) public</code></pre>
<p>Method to account for the collected protocol fees.</p>
<p><em>This method is called after each successful Governance Token Generation Event (TGE) and increases the record of the collected Governance Tokens for this pool.</em></p>
<h4 id="parameters-70">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_token</td>
<td>address</td>
<td>The address of the token contract.</td>
</tr>
<tr>
<td>_protocolTokenFee</td>
<td>uint256</td>
<td>The amount of tokens collected as protocol fees.</td>
</tr>
</tbody>
</table>
<h3 id="setprotocoltreasury">setProtocolTreasury</h3>
<pre><code class="solidity language-solidity">function setProtocolTreasury(address _protocolTreasury) public</code></pre>
<p><em>Set a new address for the protocol treasury, where the Governance tokens collected as protocol fees will be transferred.</em></p>
<h4 id="parameters-71">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_protocolTreasury</td>
<td>address</td>
<td>The new address of the protocol treasury.</td>
</tr>
</tbody>
</table>
<h3 id="setprotocoltokenfee">setProtocolTokenFee</h3>
<pre><code class="solidity language-solidity">function setProtocolTokenFee(uint256 _protocolTokenFee) public</code></pre>
<p><em>Set a new value for the protocol token fee percentage.</em></p>
<h4 id="parameters-72">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_protocolTokenFee</td>
<td>uint256</td>
<td>The new protocol token fee percentage value with 4 decimals. Examples: 1% = 10000, 100% = 1000000, 0.1% = 1000.</td>
</tr>
</tbody>
</table>
<h3 id="setregistry">setRegistry</h3>
<pre><code class="solidity language-solidity">function setRegistry(contract IRegistry _registry) external</code></pre>
<p><em>Sets new Registry contract</em></p>
<h4 id="parameters-73">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_registry</td>
<td>contract IRegistry</td>
<td>registry address</td>
</tr>
</tbody>
</table>
<h3 id="setcustomproposal">setCustomProposal</h3>
<pre><code class="solidity language-solidity">function setCustomProposal(contract ICustomProposal _customProposal) external</code></pre>
<p><em>Sets new customProposal contract</em></p>
<h4 id="parameters-74">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_customProposal</td>
<td>contract ICustomProposal</td>
<td>customProposal address</td>
</tr>
</tbody>
</table>
<h3 id="setvesting">setVesting</h3>
<pre><code class="solidity language-solidity">function setVesting(contract IVesting _vesting) external</code></pre>
<p><em>Sets new vesting</em></p>
<h4 id="parameters-75">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_vesting</td>
<td>contract IVesting</td>
<td>vesting address</td>
</tr>
</tbody>
</table>
<h3 id="setinvoice">setInvoice</h3>
<pre><code class="solidity language-solidity">function setInvoice(contract IInvoice _invoice) external</code></pre>
<p><em>Sets new invoice contract</em></p>
<h4 id="parameters-76">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_invoice</td>
<td>contract IInvoice</td>
<td>invoice address</td>
</tr>
</tbody>
</table>
<h3 id="setpoolbeacon">setPoolBeacon</h3>
<pre><code class="solidity language-solidity">function setPoolBeacon(address beacon) external</code></pre>
<p><em>Sets new pool beacon</em></p>
<h4 id="parameters-77">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beacon</td>
<td>address</td>
<td>Beacon address</td>
</tr>
</tbody>
</table>
<h3 id="settokenbeacon">setTokenBeacon</h3>
<pre><code class="solidity language-solidity">function setTokenBeacon(address beacon) external</code></pre>
<p><em>Sets new token beacon</em></p>
<h4 id="parameters-78">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beacon</td>
<td>address</td>
<td>Beacon address</td>
</tr>
</tbody>
</table>
<h3 id="settokenerc1155beacon">setTokenERC1155Beacon</h3>
<pre><code class="solidity language-solidity">function setTokenERC1155Beacon(address beacon) external</code></pre>
<p><em>Sets new tokenERC1155 beacon</em></p>
<h4 id="parameters-79">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beacon</td>
<td>address</td>
<td>Beacon address</td>
</tr>
</tbody>
</table>
<h3 id="settgebeacon">setTGEBeacon</h3>
<pre><code class="solidity language-solidity">function setTGEBeacon(address beacon) external</code></pre>
<p><em>Sets new TGE beacon</em></p>
<h4 id="parameters-80">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beacon</td>
<td>address</td>
<td>Beacon address</td>
</tr>
</tbody>
</table>
<h3 id="cancelproposal-1">cancelProposal</h3>
<pre><code class="solidity language-solidity">function cancelProposal(address pool, uint256 proposalId) public</code></pre>
<p>Cancel a proposal by the administrator.</p>
<p><em>This method is used for emergency cancellation of any proposal by an address with the ADMIN role in this contract. It is used to prevent the execution of transactions prescribed by the proposal if there are doubts about their safety.</em></p>
<h4 id="parameters-81">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>The address of the pool contract.</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>The ID of the proposal.</td>
</tr>
</tbody>
</table>
<h3 id="pause">pause</h3>
<pre><code class="solidity language-solidity">function pause() public</code></pre>
<p><em>Pause service</em></p>
<h3 id="unpause">unpause</h3>
<pre><code class="solidity language-solidity">function unpause() public</code></pre>
<p><em>Unpause service</em></p>
<h3 id="paused">paused</h3>
<pre><code class="solidity language-solidity">function paused() public view returns (bool)</code></pre>
<p><em>Returns true if the contract is paused, and false otherwise.</em></p>
<h3 id="getminsoftcap">getMinSoftCap</h3>
<pre><code class="solidity language-solidity">function getMinSoftCap() public view returns (uint256)</code></pre>
<p>This method returns the minimum soft cap accepted in the protocol.</p>
<p><em>Due to the fact that each issuance of Governance tokens involves collecting a portion of the tokens as a fee, this calculation is used to avoid conflicts related to rounding.</em></p>
<h4 id="return-values-24">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The minimum soft cap.</td>
</tr>
</tbody>
</table>
<h3 id="getprotocoltokenfee">getProtocolTokenFee</h3>
<pre><code class="solidity language-solidity">function getProtocolTokenFee(uint256 amount) public view returns (uint256)</code></pre>
<p>This method returns the size of the protocol fee charged for issuing Governance tokens.</p>
<p><em>The calculation is based on DENOM and the current fee rate, allowing the fee to be calculated for any amount of tokens planned for distribution.</em></p>
<h4 id="parameters-82">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The token amount.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-25">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The size of the fee in tokens.</td>
</tr>
</tbody>
</table>
<h3 id="getprotocolcollectedfee">getProtocolCollectedFee</h3>
<pre><code class="solidity language-solidity">function getProtocolCollectedFee(address token_) external view returns (uint256)</code></pre>
<p>This method returns the amount of Governance tokens collected as a protocol fee for each pool.</p>
<h4 id="parameters-83">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>token_</td>
<td>address</td>
<td>The address of the token contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-26">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The amount of collected protocol fee.</td>
</tr>
</tbody>
</table>
<h3 id="getmaxhardcap">getMaxHardCap</h3>
<pre><code class="solidity language-solidity">function getMaxHardCap(address _pool) public view returns (uint256)</code></pre>
<p>This method returns the maximum number of Governance tokens that can be issued in all subsequent TGEs for the pool.</p>
<p><em>Due to the protocol fee mechanism, which involves minting new token units as a protocol fee, calculating this maximum can be more complex than it seems at first glance. This method takes into account reserved and potential token units and calculates the hardcap accordingly.</em></p>
<h4 id="parameters-84">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_pool</td>
<td>address</td>
<td>The address of the pool contract for which the calculation is required.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-27">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The maximum hardcap value.</td>
</tr>
</tbody>
</table>
<h3 id="validatetgeinfo">validateTGEInfo</h3>
<pre><code class="solidity language-solidity">function validateTGEInfo(struct ITGE.TGEInfo info, uint256 cap, uint256 totalSupplyWithReserves, enum IToken.TokenType tokenType) external view</code></pre>
<p><em>This method is used for formal validation of user-defined parameters for the conducted TGE.</em></p>
<h3 id="getpooladdress">getPoolAddress</h3>
<pre><code class="solidity language-solidity">function getPoolAddress(struct ICompaniesRegistry.CompanyInfo info) public view returns (address)</code></pre>
<p><em>This method calculates the address of the pool contract using the create2 algorithm.</em></p>
<h4 id="parameters-85">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>info</td>
<td>struct ICompaniesRegistry.CompanyInfo</td>
<td>Company info</td>
</tr>
</tbody>
</table>
<h4 id="return-values-28">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address</td>
<td>Pool contract address</td>
</tr>
</tbody>
</table>
<h3 id="_getcreate2data">_getCreate2Data</h3>
<pre><code class="solidity language-solidity">function _getCreate2Data(struct ICompaniesRegistry.CompanyInfo info) internal view returns (bytes32 salt, bytes deployBytecode)</code></pre>
<p><em>Intermediate calculation for the create2 algorithm</em></p>
<h4 id="parameters-86">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>info</td>
<td>struct ICompaniesRegistry.CompanyInfo</td>
<td>Company info</td>
</tr>
</tbody>
</table>
<h4 id="return-values-29">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>salt</td>
<td>bytes32</td>
<td>Create2 salt</td>
</tr>
<tr>
<td>deployBytecode</td>
<td>bytes</td>
<td>Deployed bytecode</td>
</tr>
</tbody>
</table>
<h3 id="_createpool">_createPool</h3>
<pre><code class="solidity language-solidity">function _createPool(struct ICompaniesRegistry.CompanyInfo info) internal returns (contract IPool pool)</code></pre>
<p><em>Creating and initializing a pool</em></p>
<h4 id="return-values-30">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>contract IPool</td>
<td>Pool contract address</td>
</tr>
</tbody>
</table>
<h2 id="tge">TGE</h2>
<p>The Token Generation Event (TGE) is the cornerstone of everything related to tokens issued on the CompanyDAO protocol. TGE contracts contain the rules and deadlines for token distribution events and can influence the pool's operational activities even after they have ended.<br />
    The launch of the TGE event takes place simultaneously with the deployment of the contract, after which the option to purchase tokens becomes immediately available. Tokens purchased by a user can be partially or fully minted to the buyer's address and can also be placed in the vesting reserve either in full or for the remaining portion. Additionally, tokens acquired during the TGE and held in the buyer's balance may have their transfer functionality locked (the user owns, uses them as votes, delegates, but cannot transfer the tokens to another address).</p>
<p><em>TGE events differ by the type of tokens being distributed:
    - Governance Token Generation Event
    - Preference Token Generation Event
    When deploying the TGE contract, among other arguments, the callData field contains the token field, which contains the address of the token contract that will interact with the TGE contract. The token type can be determined from the TokenType state variable of the token contract.
    Differences between these types:
    - Governance Token Generation Event involves charging a ProtocolTokenFee in the amount set in the Service:protocolTokenFee value (percentages in DENOM notation). This fee is collected through the transferFunds() transaction after the completion of the Governance token distribution event (the funds collected from buyers go to the pool balance, and the protocolTokenFee is minted and sent to the Service:protocolTreasury).
    - Governance Token Generation Event has a mandatory minPurchase limit equal to the Service:protocolTokenFee (in the smallest indivisible token parts, taking into account Decimals and DENOM). This is done to avoid rounding conflicts or overcharges when calculating the fee for each issued token volume.
    - In addition to being launched as a result of a proposal execution, a Governance Token Generation Event can be launched by the pool Owner as long as the pool has not acquired DAO status. Preference Token Generation Event can only be launched as a result of a proposal execution.
    - A successful Governance Token Generation Event (see TGE states later) leads to the pool becoming a DAO if it didn't previously have that status.
    <a href="https://github.com/dev">@dev</a> <strong>TGE events differ by the number of previous launches:</strong>
    - primary TGE
    - secondary TGE
    As long as the sum of the totalSupply and the vesting reserve of the distributed token does not equal the cap, a TGE can be launched to issue some more of these tokens.
    The first TGE for the distribution of any token is called primary, and all subsequent ones are called secondary.
    Differences between these types:
    - A transaction to launch a primary TGE involves the simultaneous deployment of the token contract, while a secondary TGE only works with an existing token contract.
    - A secondary TGE does not have a softcap parameter, meaning that after at least one minPurchase of tokens, the TGE is considered successful.
    - When validating the hardcap (i.e., the maximum possible number of tokens available for sale/distribution within the TGE) during the creation of a primary TGE, only a formal check is performed (hardcap must not be less than softcap and not greater than cap). For a secondary TGE, tokens that will be minted during vesting claims are also taken into account.
    - In case of failure of a primary TGE for any token, that token is not considered to have any application within the protocol. It is no longer possible to conduct a TGE for such a token.</em></p>
<h3 id="denom-1">DENOM</h3>
<pre><code class="solidity language-solidity">uint256 DENOM</code></pre>
<p>Denominator for shares (such as thresholds)</p>
<p><em>The constant Service.sol:DENOM is used to work with percentage values of QuorumThreshold and DecisionThreshold thresholds, as well as for calculating the ProtocolTokenFee. In this version, it is equal to 1,000,000, for clarity stored as 100 * 10 ^ 4.
    10^4 corresponds to one percent, and 100 * 10^4 corresponds to one hundred percent.
    The value of 12.3456% will be written as 123,456, and 78.9% as 789,000.
    This notation allows specifying ratios with an accuracy of up to four decimal places in percentage notation (six decimal places in decimal notation).
    When working with the CompanyDAO frontend, the application scripts automatically convert the familiar percentage notation into the required format. When using the contracts independently, this feature of value notation should be taken into account.</em></p>
<h3 id="token">token</h3>
<pre><code class="solidity language-solidity">address token</code></pre>
<p>The address of the ERC20/ERC1155 token being distributed in this TGE</p>
<p><em>Mandatory setting for TGE, only one token can be distributed in a single TGE event</em></p>
<h3 id="tokenid">tokenId</h3>
<pre><code class="solidity language-solidity">uint256 tokenId</code></pre>
<p>The identifier of the ERC1155 token collection</p>
<p><em>For ERC1155, there is an additional restriction that units of only one collection of such tokens can be distributed in a single TGE</em></p>
<h3 id="info">info</h3>
<pre><code class="solidity language-solidity">struct ITGE.TGEInfo info</code></pre>
<p><em>Parameters for conducting the TGE, described by the ITGE.sol:TGEInfo interface</em></p>
<h3 id="_isuserwhitelisted">_isUserWhitelisted</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; bool) _isUserWhitelisted</code></pre>
<p>A whitelist of addresses allowed to participate in this TGE</p>
<p><em>A TGE can be public or private. To make the event public, simply leave the whitelist empty.
    The TGE contract can act as an airdrop - a free token distribution. To do this, set the price value to zero.
    To create a DAO with a finite number of participants, each of whom should receive an equal share of tokens, you can set the whitelist when launching the TGE as a list of the participants' addresses, and set both minPurchase and maxPurchase equal to the expression (hardcap / number of participants). To make the pool obtain DAO status only if the distribution is successful under such conditions for all project participants, you can set the softcap value equal to the hardcap. With these settings, the company will become a DAO only if all the initial participants have an equal voting power.</em></p>
<h3 id="createdat">createdAt</h3>
<pre><code class="solidity language-solidity">uint256 createdAt</code></pre>
<p><em>The block on which the TGE contract was deployed and the event begins</em></p>
<h3 id="purchaseof">purchaseOf</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; uint256) purchaseOf</code></pre>
<p><em>A mapping that stores the amount of token units purchased by each address that plays a key role in the TGE.</em></p>
<h3 id="totalpurchased">totalPurchased</h3>
<pre><code class="solidity language-solidity">uint256 totalPurchased</code></pre>
<p><em>Total amount of tokens purchased during the TGE</em></p>
<h3 id="vestingtvlreached">vestingTVLReached</h3>
<pre><code class="solidity language-solidity">bool vestingTVLReached</code></pre>
<p>Achievement of the pool's TVL as specified by the vesting settings</p>
<p><em>A flag that irreversibly becomes True only if the pool for which the TGE is being conducted is able to reach or exceed its TVL value specified in the vesting parameters.</em></p>
<h3 id="lockuptvlreached">lockupTVLReached</h3>
<pre><code class="solidity language-solidity">bool lockupTVLReached</code></pre>
<p>Achievement of the pool's TVL as specified by the lockup settings</p>
<p><em>A flag that irreversibly becomes True only if the pool for which the TGE is being conducted is able to reach or exceed its TVL value specified in the lockup parameters.</em></p>
<h3 id="vestedbalanceof">vestedBalanceOf</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; uint256) vestedBalanceOf</code></pre>
<p>A mapping that contains the amount of token units placed in vesting for a specific account</p>
<p><em>The TGE event may continue to affect other components of the protocol even after its completion and status change to "Successful" and, less frequently, "Failed". Vesting can be set up to distribute tokens over a significant period of time after the end of the TGE.
    The vesting time calculation begins with the block ending the TGE. The calculation of uniform time intervals is carried out either from the end of the cliff period block or each subsequent interval is counted from the end of the previous block.
    The Vesting.unlockedBalanceOf method shows how much of the tokens for a particular TGE may be available for a claim by an address if that address has not requested a withdrawal of any amount of tokens. The Vesting.claimableBalanceOf method shows how many tokens in total within a particular TGE an address has already requested and successfully received for withdrawal. Subtracting the second value from the first using the same arguments for method calls will give you the number of tokens currently available for withdrawal by that address.
    Additionally, one of the conditions for unlocking tokens under the vesting program can be setting a cumulative pool balance of a specified amount. The compliance with this condition starts to be tracked by the backend, and as soon as the pool balance reaches or exceeds the specified amount even for a moment, the backend, on behalf of the wallet with the SERVICE_MANAGER role, sends a transaction to the vesting contract's setClaimTVLReached(address tge) method. Executing this transaction changes the value of the flag in the mapping mapping(address => bool) with a key equal to the TGE address. Raising this flag is irreversible, meaning that a one-time occurrence of the condition guarantees that the token request now depends only on the second part of the conditions related to the passage of time. The calculation of the cliff period and additional distribution intervals is not related to raising this flag, both conditions are independent of each other, not mandatory for simultaneous use in settings, but mandatory for simultaneous compliance if they were used in one set of settings.
    The vesting of one TGE does not affect the vesting of another TGE.</em></p>
<h3 id="totalvested">totalVested</h3>
<pre><code class="solidity language-solidity">uint256 totalVested</code></pre>
<p><em>Total number of tokens to be distributed within the vesting period</em></p>
<h3 id="protocolfee">protocolFee</h3>
<pre><code class="solidity language-solidity">uint256 protocolFee</code></pre>
<p>Protocol fee at the time of TGE creation</p>
<p><em>Since the protocol fee can be changed, the actual value at the time of contract deployment is fixed in the contract's memory to avoid dependencies on future states of the Service contract.</em></p>
<h3 id="isprotocoltokenfeeclaimed">isProtocolTokenFeeClaimed</h3>
<pre><code class="solidity language-solidity">bool isProtocolTokenFeeClaimed</code></pre>
<p>Protocol fee payment</p>
<p><em>A flag that irreversibly becomes True after a successful transfer of the protocol fee to the address specified in the Service contract.
Used only for Governance Token Generation Event.</em></p>
<h3 id="totalprotocolfee">totalProtocolFee</h3>
<pre><code class="solidity language-solidity">uint256 totalProtocolFee</code></pre>
<p><em>Total number of token units that make up the protocol fee</em></p>
<h3 id="vesting-1">vesting</h3>
<pre><code class="solidity language-solidity">contract IVesting vesting</code></pre>
<p>Vesting contract address</p>
<p><em>The TGE contract works closely with the Vesting contract, with a separate instance being issued for each token generation event, while there is only one Vesting contract. Together, they contain the most comprehensive information about a user's purchases, tokens in reserve but not yet issued, and the conditions for locking and unlocking tokens. Moreover, the TGE contract has a token buyback function under specific conditions (see the "Redeem" section for more details).
    One TGE contract is used for the distribution of only one protocol token (the token contract address is specified when launching the TGE). At any given time, there can be only one active TGE for a single token.</em></p>
<h3 id="purchased">Purchased</h3>
<pre><code class="solidity language-solidity">event Purchased(address buyer, uint256 amount)</code></pre>
<p><em>Event emitted upon successful purchase (or distribution if the token unit price is 0)</em></p>
<h4 id="parameters-87">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>buyer</td>
<td>address</td>
<td>Address of the token recipient (buyer)</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>Number of token units acquired</td>
</tr>
</tbody>
</table>
<h3 id="protocoltokenfeeclaimed">ProtocolTokenFeeClaimed</h3>
<pre><code class="solidity language-solidity">event ProtocolTokenFeeClaimed(address token, uint256 tokenFee)</code></pre>
<p><em>Event emitted after successful claiming of the protocol fee</em></p>
<h4 id="parameters-88">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>token</td>
<td>address</td>
<td>Address of the token contract</td>
</tr>
<tr>
<td>tokenFee</td>
<td>uint256</td>
<td>Amount of tokens transferred as payment for the protocol fee</td>
</tr>
</tbody>
</table>
<h3 id="redeemed">Redeemed</h3>
<pre><code class="solidity language-solidity">event Redeemed(address account, uint256 refundValue)</code></pre>
<p><em>Event emitted upon redeeming tokens in case of a failed TGE.</em></p>
<h4 id="parameters-89">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>Redeemer address</td>
</tr>
<tr>
<td>refundValue</td>
<td>uint256</td>
<td>Refund value</td>
</tr>
</tbody>
</table>
<h3 id="fundstransferred">FundsTransferred</h3>
<pre><code class="solidity language-solidity">event FundsTransferred(uint256 amount)</code></pre>
<p><em>Event emitted upon transferring the raised funds to the pool contract address.</em></p>
<h4 id="parameters-90">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>uint256</td>
<td>Amount of tokens/ETH transferred</td>
</tr>
</tbody>
</table>
<h3 id="constructor-4">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<p>Contract constructor.</p>
<p><em>This contract uses OpenZeppelin upgrades and has no need for a constructor function.
The constructor is replaced with an initializer function.
This method disables the initializer feature of the OpenZeppelin upgrades plugin, preventing the initializer methods from being misused.</em></p>
<h3 id="initialize-5">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(address _service, address _token, uint256 _tokenId, string _uri, struct ITGE.TGEInfo _info, uint256 _protocolFee) external</code></pre>
<p><em>Constructor function, can only be called once. In this method, settings for the TGE event are assigned, such as the contract of the token implemented using TGE, as well as the TGEInfo structure, which includes the parameters of purchase, vesting, and lockup. If no lockup or vesting conditions were set for the TVL value when creating the TGE, then the TVL achievement flag is set to true from the very beginning.</em></p>
<h4 id="parameters-91">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_service</td>
<td>address</td>
<td>Service contract</td>
</tr>
<tr>
<td>_token</td>
<td>address</td>
<td>TGE's token</td>
</tr>
<tr>
<td>_tokenId</td>
<td>uint256</td>
<td>TGE's tokenId</td>
</tr>
<tr>
<td>_uri</td>
<td>string</td>
<td>Metadata URL for the ERC1155 token collection</td>
</tr>
<tr>
<td>_info</td>
<td>struct ITGE.TGEInfo</td>
<td>TGE parameters</td>
</tr>
<tr>
<td>_protocolFee</td>
<td>uint256</td>
<td>Protocol fee snapshot</td>
</tr>
</tbody>
</table>
<h3 id="purchase">purchase</h3>
<pre><code class="solidity language-solidity">function purchase(uint256 amount) external payable</code></pre>
<p>This method is used for purchasing pool tokens.</p>
<p><em>Any blockchain address can act as a buyer (TGE contract user) of tokens if the following conditions are met:
    - active event status (TGE.sol:state method returns the Active code value / "1")
    - the event is public (TGE.sol:info.Whitelist is empty) or the user's address is on the whitelist of addresses admitted to the event
    - the number of tokens purchased by the address is not less than TGE.sol:minPurchase (a common rule for all participants) and not more than TGE.sol:maxPurchaseOf(address) (calculated individually for each address)
    The TGEInfo of each such event also contains settings for the order in which token buyers receive their purchases and from when and to what extent they can start managing them.
    However, in any case, each address that made a purchase is mentioned in the TGE.sol:purchaseOf[] mapping. This record serves as proof of full payment for the purchase and confirmation of the buyer's status, even if as a result of the transaction, not a single token was credited to the buyer's address.
    After each purchase transaction, TGE.sol:purchase calculates what part of the purchase should be issued and immediately transferred to the buyer's balance, and what part should be left as a reserve (records, not issued tokens) in vesting until the prescribed settings for unlocking these tokens occur.</em></p>
<h3 id="redeem">redeem</h3>
<pre><code class="solidity language-solidity">function redeem() external</code></pre>
<p>Redeem acquired tokens with a refund of the spent assets.</p>
<p><em>In the contract of an unsuccessful TGE, the redeem() method becomes active, allowing any token buyer to return them to the contract for subsequent burning. As a result of this transaction, the records of the user's purchases within this TGE will be zeroed out (or reduced), and the spent ETH or ERC20 tokens will be returned to their balance.
    If the buyer has a record of tokens locked under the vesting program for this TGE, they will not be burned, and the record of the vesting payment will simply be deleted. In this case, the transaction will also end with a transfer of the spent funds back to the buyer.
    The buyer cannot return more tokens than they purchased in this TGE; this contract keeps a record of the user's total purchase amount and reduces it with each call of the redeem token method. This can happen if the purchased tokens were distributed to other wallets, and after the end of the TGE, the buyer requests redemption after each transfer back to the purchase address.</em></p>
<h3 id="setlockuptvlreached">setLockupTVLReached</h3>
<pre><code class="solidity language-solidity">function setLockupTVLReached() external</code></pre>
<p><em>Set the flag that the condition for achieving the pool balance of the value specified in the lockup settings is met. The action is irreversible.</em></p>
<h3 id="transferfunds">transferFunds</h3>
<pre><code class="solidity language-solidity">function transferFunds() external</code></pre>
<p><em>This method is used to perform the following actions for a successful TGE after its completion: transfer funds collected from buyers in the form of info.unitofaccount tokens or ETH to the address of the pool to which TGE belongs (if info.price is 0, then this action is not performed), as well as for Governance tokens make a minting of the percentage of the amount of all user purchases specified in the Service.sol protocolTokenFee contract and transfer it to the address specified in the Service.sol contract in the protocolTreasury() getter. Can be executed only once. Any address can call the method.</em></p>
<h3 id="_claimprotocoltokenfee">_claimProtocolTokenFee</h3>
<pre><code class="solidity language-solidity">function _claimProtocolTokenFee() private</code></pre>
<p>This method is used to transfer funds raised during the TGE to the address of the pool contract that conducted the TGE.</p>
<p><em>The method can be called by any address. For safe execution, this method does not take any call arguments and only triggers for successful TGEs.</em></p>
<h3 id="maxpurchaseof">maxPurchaseOf</h3>
<pre><code class="solidity language-solidity">function maxPurchaseOf(address account) public view returns (uint256)</code></pre>
<p><em>Shows the maximum possible number of tokens to be purchased by a specific address, taking into account whether the user is on the white list and 0 what amount of purchases he made within this TGE.</em></p>
<h4 id="return-values-31">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>Amount of tokens</td>
</tr>
</tbody>
</table>
<h3 id="state">state</h3>
<pre><code class="solidity language-solidity">function state() public view returns (enum ITGE.State)</code></pre>
<p>A state of a Token Generation Event</p>
<p><em>A TGE event can be in one of the following states:
    - Active
    - Failed
    - Successful
    In TGEInfo, the three most important parameters used to determine the event's state are specified:
    - hardcap - the maximum number of tokens that can be distributed during the event (the value is stored considering the token's Decimals)
    - softcap - the minimum expected number of tokens that should be distributed during the event (the value is stored considering the token's Decimals)
    - duration - the duration of the event (the number of blocks since the TGE deployment transaction)
    A successful outcome of the event and the assignment of the "Successful" status to the TGE occurs if:
    - no fewer than duration blocks have passed since the TGE launch, and no fewer than softcap tokens have been acquired
    OR
    - 100% of the hardcap tokens have been acquired at any point during the event
    If no fewer than duration blocks have passed since the TGE launch and fewer than softcap tokens have been acquired, the event is considered "Failed".
    If fewer than 100% of the hardcap tokens have been acquired, but fewer than duration blocks have passed since the TGE launch, the event is considered "Active".</em></p>
<h4 id="return-values-32">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>enum ITGE.State</td>
<td>State code</td>
</tr>
</tbody>
</table>
<h3 id="transferunlocked">transferUnlocked</h3>
<pre><code class="solidity language-solidity">function transferUnlocked() public view returns (bool)</code></pre>
<p>The given getter shows whether the transfer method is available for tokens that were distributed using a specific TGE contract. If the lockup period is over or if the lockup was not provided for this TGE, the getter always returns true.</p>
<p><em>In contrast to vesting, lockup contains a simplified system of conditions (no additional distribution spread over equal time intervals), affects tokens located in the contract address, and does not involve actions related to minting or burning tokens.
    To configure lockup in TGEInfo, only two settings are specified: "lockupDuration" and "lockupTVL" (pool balance). The lockup duration is counted from the TGE creation block.
    Lockup locks the transfer of tokens purchased during the TGE for a period equal to the lockupDuration blocks and does not allow unlocking until the pool balance reaches lockupTVL. The address can use these tokens for Governance activities; they are on the balance and counted as votes.
    Unlocking by TVL occurs with a transaction similar to vesting. The SERVICE_MANAGER address can send a setLockupTVLReached() transaction to the TGE contract, which irreversibly changes the value of this condition flag to "true".
    Vesting and lockup are completely parallel entities. Tokens can be unlocked under the lockup program but remain in vesting. The lockup of one TGE does not affect the lockup of another TGE.</em></p>
<h4 id="return-values-33">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>bool Is transfer available</td>
</tr>
</tbody>
</table>
<h3 id="lockedbalanceof">lockedBalanceOf</h3>
<pre><code class="solidity language-solidity">function lockedBalanceOf(address account) external view returns (uint256)</code></pre>
<p><em>Shows the number of TGE tokens blocked in this contract. If the lockup is completed or has not been assigned, the method returns 0 (all tokens on the address balance are available for transfer). If the lockup period is still active, then the difference between the tokens purchased by the user and those in the vesting is shown (both parameters are only for this TGE).</em></p>
<h4 id="parameters-92">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>Account address</td>
</tr>
</tbody>
</table>
<h4 id="return-values-34">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>Locked balance</td>
</tr>
</tbody>
</table>
<h3 id="redeemablebalanceof">redeemableBalanceOf</h3>
<pre><code class="solidity language-solidity">function redeemableBalanceOf(address account) external view returns (uint256)</code></pre>
<p><em>Shows the number of TGE tokens available for redeem for <code>account</code></em></p>
<h4 id="parameters-93">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>Account address</td>
</tr>
</tbody>
</table>
<h4 id="return-values-35">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>Redeemable balance of the address</td>
</tr>
</tbody>
</table>
<h3 id="gettotalpurchasedvalue">getTotalPurchasedValue</h3>
<pre><code class="solidity language-solidity">function getTotalPurchasedValue() public view returns (uint256)</code></pre>
<p><em>The given getter shows how much info.unitofaccount was collected within this TGE. To do this, the amount of tokens purchased by all buyers is multiplied by info.price.</em></p>
<h4 id="return-values-36">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 Total value</td>
</tr>
</tbody>
</table>
<h3 id="gettotalvestedvalue">getTotalVestedValue</h3>
<pre><code class="solidity language-solidity">function getTotalVestedValue() public view returns (uint256)</code></pre>
<p><em>This getter shows the total value of all tokens that are in the vesting. Tokens that were transferred to user’s wallet addresses upon request for successful TGEs and that were burned as a result of user funds refund for unsuccessful TGEs are not taken into account.</em></p>
<h4 id="return-values-37">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 Total value</td>
</tr>
</tbody>
</table>
<h3 id="getuserwhitelist">getUserWhitelist</h3>
<pre><code class="solidity language-solidity">function getUserWhitelist() external view returns (address[])</code></pre>
<p><em>This method returns the full list of addresses allowed to participate in the TGE.</em></p>
<h4 id="return-values-38">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address[]</td>
<td>address An array of whitelist addresses</td>
</tr>
</tbody>
</table>
<h3 id="isuserwhitelisted">isUserWhitelisted</h3>
<pre><code class="solidity language-solidity">function isUserWhitelisted(address account) public view returns (bool)</code></pre>
<p><em>Checks if user is whitelisted.</em></p>
<h4 id="parameters-94">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>User address</td>
</tr>
</tbody>
</table>
<h4 id="return-values-39">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>'True' if the whitelist is empty (public TGE) or if the address is found in the whitelist, 'False' otherwise.</td>
</tr>
</tbody>
</table>
<h3 id="iserc1155tge">isERC1155TGE</h3>
<pre><code class="solidity language-solidity">function isERC1155TGE() public view returns (bool)</code></pre>
<p><em>This method indicates whether this event was launched to implement ERC1155 tokens.</em></p>
<h4 id="return-values-40">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>bool Flag if ERC1155 TGE</td>
</tr>
</tbody>
</table>
<h3 id="getend">getEnd</h3>
<pre><code class="solidity language-solidity">function getEnd() external view returns (uint256)</code></pre>
<p><em>Returns the block number at which the event ends.</em></p>
<h4 id="return-values-41">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 Block number</td>
</tr>
</tbody>
</table>
<h3 id="getinfo">getInfo</h3>
<pre><code class="solidity language-solidity">function getInfo() external view returns (struct ITGE.TGEInfo)</code></pre>
<p>This method returns the immutable settings with which the TGE was launched.</p>
<p><em>The rules for conducting an event are defined in the TGEInfo structure, which is passed within the calldata when calling one of the TGEFactory contract functions responsible for launching the TGE. For more information about the structure, see the "Interfaces" section. The variables mentioned below should be understood as attributes of the TGEInfo structure.
    A TGE can be public or private. To make the event public, simply leave the whitelist empty.
    The TGE contract can act as an airdrop - a free token distribution. To do this, set the price value to zero.
    To create a DAO with a finite number of participants, each of whom should receive an equal share of tokens, you can set the whitelist when launching the TGE as a list of the participants' addresses, and set both minPurchase and maxPurchase equal to the expression (hardcap / number of participants). To make the pool obtain DAO status only if the distribution is successful under such conditions for all project participants, you can set the softcap value equal to the hardcap. With these settings, the company will become a DAO only if all the initial participants have an equal voting power.</em></p>
<h4 id="return-values-42">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>struct ITGE.TGEInfo</td>
<td>The settings in the form of a TGEInfo structure</td>
</tr>
</tbody>
</table>
<h3 id="getprotocoltokenfee-1">getProtocolTokenFee</h3>
<pre><code class="solidity language-solidity">function getProtocolTokenFee(uint256 amount) public view returns (uint256)</code></pre>
<p><em>This method returns the number of tokens that are currently due as protocol fees during the TGE.</em></p>
<h4 id="return-values-43">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The number of tokens</td>
</tr>
</tbody>
</table>
<h3 id="onlystate">onlyState</h3>
<pre><code class="solidity language-solidity">modifier onlyState(enum ITGE.State state_)</code></pre>
<p>Modifier that allows the method to be called only if the TGE state is equal to the specified state.</p>
<h3 id="onlywhitelisteduser">onlyWhitelistedUser</h3>
<pre><code class="solidity language-solidity">modifier onlyWhitelistedUser()</code></pre>
<p>Modifier that allows the method to be called only by an account that is whitelisted for the TGE or if the TGE is created as public.</p>
<h3 id="onlymanager-2">onlyManager</h3>
<pre><code class="solidity language-solidity">modifier onlyManager()</code></pre>
<p>Modifier that allows the method to be called only by an account that has the ADMIN role in the Service contract.</p>
<h3 id="whenpoolnotpaused-1">whenPoolNotPaused</h3>
<pre><code class="solidity language-solidity">modifier whenPoolNotPaused()</code></pre>
<p>Modifier that allows the method to be called only if the pool associated with the event is not in a paused state.</p>
<h2 id="tgefactory-1">TGEFactory</h2>
<p>Event emitted on creation of primary TGE.</p>
<p><em>Deployment of a TGE can occur both within the execution of transactions prescribed by a proposal, and during the execution of a transaction initiated by the pool owner, who has not yet become a DAO.</em></p>
<h3 id="service-2">service</h3>
<pre><code class="solidity language-solidity">contract IService service</code></pre>
<p>Service contract address</p>
<h3 id="primarytgecreated">PrimaryTGECreated</h3>
<pre><code class="solidity language-solidity">event PrimaryTGECreated(address pool, address tge, address token)</code></pre>
<p><em>Event emitted when the primary TGE contract is deployed.</em></p>
<h4 id="parameters-95">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the pool for which the TGE is launched.</td>
</tr>
<tr>
<td>tge</td>
<td>address</td>
<td>Address of the deployed TGE contract.</td>
</tr>
<tr>
<td>token</td>
<td>address</td>
<td>Address of the token contract.</td>
</tr>
</tbody>
</table>
<h3 id="secondarytgecreated">SecondaryTGECreated</h3>
<pre><code class="solidity language-solidity">event SecondaryTGECreated(address pool, address tge, address token)</code></pre>
<p><em>Event emitted when a secondary TGE contract operating with ERC20 tokens is deployed.</em></p>
<h4 id="parameters-96">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the pool for which the TGE is launched.</td>
</tr>
<tr>
<td>tge</td>
<td>address</td>
<td>Address of the deployed TGE contract.</td>
</tr>
<tr>
<td>token</td>
<td>address</td>
<td>Address of the ERC20 token contract.</td>
</tr>
</tbody>
</table>
<h3 id="secondarytgeerc1155created">SecondaryTGEERC1155Created</h3>
<pre><code class="solidity language-solidity">event SecondaryTGEERC1155Created(address pool, address tge, address token, uint256 tokenId)</code></pre>
<p><em>Event emitted when a secondary TGE contract operating with ERC1155 tokens is * deployed.</em></p>
<h4 id="parameters-97">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the pool for which the TGE is launched.*</td>
</tr>
<tr>
<td>tge</td>
<td>address</td>
<td>Address of the deployed TGE contract.*</td>
</tr>
<tr>
<td>token</td>
<td>address</td>
<td>Address of the ERC1155 token contract.*</td>
</tr>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>Identifier of the ERC1155 token collection.</td>
</tr>
</tbody>
</table>
<h3 id="onlypool-1">onlyPool</h3>
<pre><code class="solidity language-solidity">modifier onlyPool()</code></pre>
<p>Modifier that allows the method to be called only by the Pool contract.</p>
<h3 id="whennotpaused">whenNotPaused</h3>
<pre><code class="solidity language-solidity">modifier whenNotPaused()</code></pre>
<p>Modifier that allows the method to be called only if the Service contract is not paused.</p>
<h3 id="constructor-5">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<p>Contract constructor.</p>
<p><em>This contract uses OpenZeppelin upgrades and has no need for a constructor function.
The constructor is replaced with an initializer function.
This method disables the initializer feature of the OpenZeppelin upgrades plugin, preventing the initializer methods from being misused.</em></p>
<h3 id="initialize-6">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(contract IService service_) external</code></pre>
<p>Contract initializer</p>
<p><em>This method replaces the constructor for upgradeable contracts. It also sets the address of the Service contract in the contract's storage.</em></p>
<h4 id="parameters-98">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>service_</td>
<td>contract IService</td>
<td>The address of the Service contract.</td>
</tr>
</tbody>
</table>
<h3 id="createprimarytge">createPrimaryTGE</h3>
<pre><code class="solidity language-solidity">function createPrimaryTGE(address poolAddress, struct IToken.TokenInfo tokenInfo, struct ITGE.TGEInfo tgeInfo, string metadataURI, struct IGovernanceSettings.NewGovernanceSettings governanceSettings_, address[] secretary, address[] executor) external</code></pre>
<p><em>This method is used to launch the primary TGE of the Governance token. When launching such a TGE, a new Token contract is deployed with TokenType = "Governance". If this TGE is successful, it will no longer be possible to repeat such a launch, and the created token will irreversibly become the Governance token of the pool.
Simultaneously with contract deployment, Governance Settings and lists of secretaries and executors are set.</em></p>
<h4 id="parameters-99">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>poolAddress</td>
<td>address</td>
<td>Pool address.</td>
</tr>
<tr>
<td>tokenInfo</td>
<td>struct IToken.TokenInfo</td>
<td>New token parameters (token type, decimals &amp; description are ignored)</td>
</tr>
<tr>
<td>tgeInfo</td>
<td>struct ITGE.TGEInfo</td>
<td>Pool TGE parameters</td>
</tr>
<tr>
<td>metadataURI</td>
<td>string</td>
<td>Metadata URI</td>
</tr>
<tr>
<td>governanceSettings_</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>Set of Governance settings</td>
</tr>
<tr>
<td>secretary</td>
<td>address[]</td>
<td>Secretary address</td>
</tr>
<tr>
<td>executor</td>
<td>address[]</td>
<td>Executor address</td>
</tr>
</tbody>
</table>
<h3 id="createsecondarytge">createSecondaryTGE</h3>
<pre><code class="solidity language-solidity">function createSecondaryTGE(address token, struct ITGE.TGEInfo tgeInfo, struct IToken.TokenInfo tokenInfo, string metadataURI) external</code></pre>
<p><em>This method allows users to launch primary and secondary TGEs for Governance and Preference tokens deployed based on the ERC20 contract. The creation of a token occurs if the TGE involves the distribution of a previously nonexistent Preference token. Launch is only possible by executing a successful proposal.</em></p>
<h4 id="parameters-100">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>token</td>
<td>address</td>
<td>ERC20 token address for distribution in the TGE</td>
</tr>
<tr>
<td>tgeInfo</td>
<td>struct ITGE.TGEInfo</td>
<td>TGE parameters</td>
</tr>
<tr>
<td>tokenInfo</td>
<td>struct IToken.TokenInfo</td>
<td>Token parameters</td>
</tr>
<tr>
<td>metadataURI</td>
<td>string</td>
<td>Metadata URI</td>
</tr>
</tbody>
</table>
<h3 id="createsecondarytgeerc1155">createSecondaryTGEERC1155</h3>
<pre><code class="solidity language-solidity">function createSecondaryTGEERC1155(address token, uint256 tokenId, string uri, struct ITGE.TGEInfo tgeInfo, struct IToken.TokenInfo tokenInfo, string metadataURI) external</code></pre>
<p><em>This method launches a secondary TGE for a specified series of ERC1155 Preference tokens. If an unused series is being used, the maximum cap for this series is determined within this transaction. If no token address is specified, a new ERC1155 Preference token contract is deployed.</em></p>
<h4 id="parameters-101">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>token</td>
<td>address</td>
<td>ERC1155 token address for distribution in the TGE</td>
</tr>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>ERC1155 token collection address for distribution of units in the TGE</td>
</tr>
<tr>
<td>uri</td>
<td>string</td>
<td>Metadata URI according to the ERC1155 specification</td>
</tr>
<tr>
<td>tgeInfo</td>
<td>struct ITGE.TGEInfo</td>
<td>TGE parameters</td>
</tr>
<tr>
<td>tokenInfo</td>
<td>struct IToken.TokenInfo</td>
<td>Token parameters</td>
</tr>
<tr>
<td>metadataURI</td>
<td>string</td>
<td>Metadata URI</td>
</tr>
</tbody>
</table>
<h3 id="_createsecondarytge">_createSecondaryTGE</h3>
<pre><code class="solidity language-solidity">function _createSecondaryTGE(address token, uint256 tokenId, string uri, struct ITGE.TGEInfo tgeInfo, struct IToken.TokenInfo tokenInfo, string metadataURI) internal returns (address, contract ITGE)</code></pre>
<h3 id="_createinitialpreferencetge">_createInitialPreferenceTGE</h3>
<pre><code class="solidity language-solidity">function _createInitialPreferenceTGE(uint256 tokenId, string uri, struct ITGE.TGEInfo tgeInfo, struct IToken.TokenInfo tokenInfo, string metadataURI) internal returns (address, contract ITGE)</code></pre>
<p><em>This internal method implements the logic of launching a TGE for Preference tokens that do not yet have their own contract.</em></p>
<h4 id="parameters-102">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>ERC1155 token collection address for distribution of units in the TGE</td>
</tr>
<tr>
<td>uri</td>
<td>string</td>
<td>Metadata URI according to the ERC1155 specification</td>
</tr>
<tr>
<td>tgeInfo</td>
<td>struct ITGE.TGEInfo</td>
<td>TGE parameters</td>
</tr>
<tr>
<td>tokenInfo</td>
<td>struct IToken.TokenInfo</td>
<td>Token parameters</td>
</tr>
<tr>
<td>metadataURI</td>
<td>string</td>
<td>Metadata URI</td>
</tr>
</tbody>
</table>
<h3 id="_createtge">_createTGE</h3>
<pre><code class="solidity language-solidity">function _createTGE(string metadataURI, address pool) internal returns (contract ITGE tge)</code></pre>
<p><em>This method deploys the TGE contract and returns its address after creation.</em></p>
<h4 id="parameters-103">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>metadataURI</td>
<td>string</td>
<td>TGE metadata URI</td>
</tr>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
</tbody>
</table>
<h4 id="return-values-44">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>contract ITGE</td>
<td>TGE contract</td>
</tr>
</tbody>
</table>
<h2 id="token-1">Token</h2>
<p>Tokens are the primary quantitative characteristic of all entities within the protocol. In addition to their inherent function as a unit of calculation, tokens can also be used as votes and as a unit indicating the degree of participation of an address in an off-chain or on-chain pool project. Tokens of any type can only be issued within the framework of a TGE (Token Generation Event), and by using vesting settings, such a TGE can divide the issuance of purchased or airdropped tokens into stages, as well as temporarily block the ability to transfer them from one address to another.</p>
<p><em>An expanded ERC20 contract, based on which tokens of various types are issued. At the moment, the protocol provides for 2 types of tokens: Governance, which must be created simultaneously with the pool, existing for the pool only in the singular and participating in voting, and Preference, which may be several for one pool and which do not participate in voting in any way.</em></p>
<h3 id="service-3">service</h3>
<pre><code class="solidity language-solidity">contract IService service</code></pre>
<p><em>Service contract address</em></p>
<h3 id="pool-1">pool</h3>
<pre><code class="solidity language-solidity">address pool</code></pre>
<p><em>Pool contract address</em></p>
<h3 id="tokentype">tokenType</h3>
<pre><code class="solidity language-solidity">enum IToken.TokenType tokenType</code></pre>
<p>Token type code</p>
<p><em>Code "1" - Governance Token is the main token of the pool, compatible with the ERC20 standard. One such token is equal to one vote. One pool can only have one contract of this type of token. When the primary TGE is launched, dedicated to the distribution of this type of token, the token is only a candidate for the Governance role.
    In case of a successful TGE, it remains the Governance token of the pool forever.
    In case of a failed TGE, it carries no weight and voting power for Governance procedures; another token can be appointed in its place through a repeated primary TGE. The cap is set once during the launch of the primary TGE.
    During each TGE, an additional issuance of Service:ProtocolTokenFee percent of the total volume of tokens distributed during the event takes place and is transferred to the balance of the Service:ProtocolTreasury address.
Code "2" - Preference Token is an additional pool token, compatible with the ERC20 standard. It does not have voting power. One pool can have multiple independent and non-interacting tokens of this type.
    In case of a successful TGE, it is recognized by the pool as a Preference token forever.
    In case of a failed TGE, the pool forgets about such a token, not recognizing it as a Preference token.
    The cap is set once during the launch of the primary TGE.</em></p>
<h3 id="description">description</h3>
<pre><code class="solidity language-solidity">string description</code></pre>
<p><em>Preference token description, allows up to 5000 characters, for others - ""</em></p>
<h3 id="tgelist">tgeList</h3>
<pre><code class="solidity language-solidity">address[] tgeList</code></pre>
<p>All TGEs associated with this token</p>
<p><em>A list of TGE contract addresses that have been launched to distribute this token. If any of the elements in the list have a "Successful" state, it means that the token is valid and used by the pool. If there are no such TGEs, the token can be considered unsuccessful, meaning it is detached from the pool.</em></p>
<h3 id="_decimals">_decimals</h3>
<pre><code class="solidity language-solidity">uint8 _decimals</code></pre>
<p>Token decimals</p>
<p><em>This parameter is mandatory for all ERC20 tokens and is set to 18 by default. It indicates the precision applied when calculating a particular token. It can also be said that 10 raised to the power of minus decimal is the minimum indivisible amount of the token.</em></p>
<h3 id="totalvested-1">totalVested</h3>
<pre><code class="solidity language-solidity">uint256 totalVested</code></pre>
<p><em>Total Vested tokens for all TGEs</em></p>
<h3 id="tgewithlockedtokenslist">tgeWithLockedTokensList</h3>
<pre><code class="solidity language-solidity">address[] tgeWithLockedTokensList</code></pre>
<p><em>List of all TGEs with locked tokens</em></p>
<h3 id="totalprotocolfeereserved">totalProtocolFeeReserved</h3>
<pre><code class="solidity language-solidity">uint256 totalProtocolFeeReserved</code></pre>
<p><em>Total amount of tokens reserved for the minting protocol fee</em></p>
<h3 id="constructor-6">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<p>Contract constructor.</p>
<p><em>This contract uses OpenZeppelin upgrades and has no need for a constructor function.
The constructor is replaced with an initializer function.
This method disables the initializer feature of the OpenZeppelin upgrades plugin, preventing the initializer methods from being misused.</em></p>
<h3 id="initialize-7">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(contract IService service_, address pool_, struct IToken.TokenInfo info, address primaryTGE_) external</code></pre>
<p><em>Token creation, can only be started once. At the same time, the TGE contract, which sells the created token, is necessarily simultaneously deployed and receives an entry in the Registry. For the Governance token, the Name field for the ERC20 standard is taken from the trademark of the Pool contract to which the deployed token belongs. For Preference tokens, you can set an arbitrary value of the Name field.</em></p>
<h4 id="parameters-104">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>service_</td>
<td>contract IService</td>
<td>The address of the Service contract</td>
</tr>
<tr>
<td>pool_</td>
<td>address</td>
<td>The address of the pool contract</td>
</tr>
<tr>
<td>info</td>
<td>struct IToken.TokenInfo</td>
<td>The token parameters, including its type, in the form of a structure described in the TokenInfo method</td>
</tr>
<tr>
<td>primaryTGE_</td>
<td>address</td>
<td>The address of the primary TGE for this token</td>
</tr>
</tbody>
</table>
<h3 id="mint">mint</h3>
<pre><code class="solidity language-solidity">function mint(address to, uint256 amount) external</code></pre>
<p><em>Minting of new tokens. Only the TGE or Vesting contract can mint tokens, there is no other way to get an additional issue. If the user who is being minted does not have tokens, they are sent to delegation on his behalf.</em></p>
<h4 id="parameters-105">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td>address</td>
<td>The address of the account for which new token units are being minted</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The number of tokens being minted</td>
</tr>
</tbody>
</table>
<h3 id="burn">burn</h3>
<pre><code class="solidity language-solidity">function burn(address from, uint256 amount) external</code></pre>
<p><em>Method for burning tokens. It can be called by both the token owner and the TGE contract to burn returned tokens during redeeming.</em></p>
<h4 id="parameters-106">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td>address</td>
<td>The address of the account</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens</td>
</tr>
</tbody>
</table>
<h3 id="addtge">addTGE</h3>
<pre><code class="solidity language-solidity">function addTGE(address tge) external</code></pre>
<p><em>This method adds the TGE contract address to the TGEList of this token.</em></p>
<h4 id="parameters-107">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>The TGE address</td>
</tr>
</tbody>
</table>
<h3 id="settgevestedtokens">setTGEVestedTokens</h3>
<pre><code class="solidity language-solidity">function setTGEVestedTokens(uint256 amount) external</code></pre>
<p><em>This method modifies the number of token units that are vested and reserved for claiming by users.</em></p>
<h4 id="parameters-108">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens</td>
</tr>
</tbody>
</table>
<h3 id="setprotocolfeereserved">setProtocolFeeReserved</h3>
<pre><code class="solidity language-solidity">function setProtocolFeeReserved(uint256 amount) external</code></pre>
<p><em>This method modifies the number of token units that are reserved as protocol fee.</em></p>
<h4 id="parameters-109">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens</td>
</tr>
</tbody>
</table>
<h3 id="decimals">decimals</h3>
<pre><code class="solidity language-solidity">function decimals() public view returns (uint8)</code></pre>
<p><em>This method returns the precision level for the fractional parts of this token.</em></p>
<h4 id="return-values-45">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint8</td>
<td>Decimals</td>
</tr>
</tbody>
</table>
<h3 id="cap">cap</h3>
<pre><code class="solidity language-solidity">function cap() public view returns (uint256)</code></pre>
<p><em>This method returns the maximum allowable token emission.</em></p>
<h4 id="return-values-46">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The number of tokens taking into account the Decimals parameter</td>
</tr>
</tbody>
</table>
<h3 id="symbol">symbol</h3>
<pre><code class="solidity language-solidity">function symbol() public view returns (string)</code></pre>
<p><em>This method returns the short name of the token, its ticker for listing.</em></p>
<h4 id="return-values-47">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>string</td>
<td>A string with the name</td>
</tr>
</tbody>
</table>
<h3 id="unlockedbalanceof">unlockedBalanceOf</h3>
<pre><code class="solidity language-solidity">function unlockedBalanceOf(address account) public view returns (uint256)</code></pre>
<p><em>The given getter returns the total balance of the address that is not locked for transfer, taking into account all the TGEs with which this token was distributed.
It is the difference between the actual balance of the account and its locked portion.</em></p>
<h4 id="parameters-110">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The address of the account</td>
</tr>
</tbody>
</table>
<h4 id="return-values-48">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>Unlocked balance of the account</td>
</tr>
</tbody>
</table>
<h3 id="isprimarytgesuccessful">isPrimaryTGESuccessful</h3>
<pre><code class="solidity language-solidity">function isPrimaryTGESuccessful() external view returns (bool)</code></pre>
<p><em>This method indicates whether a successful TGE has been conducted for this token. To determine this, it is sufficient to check the first event from the list of all TGEs. If it ended in failure, then this token cannot be considered active for its pool.</em></p>
<h4 id="return-values-49">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>bool Is any TGE successful</td>
</tr>
</tbody>
</table>
<h3 id="gettgelist">getTGEList</h3>
<pre><code class="solidity language-solidity">function getTGEList() external view returns (address[])</code></pre>
<p><em>This method returns the list of addresses of all TGE contracts ever deployed for this token.</em></p>
<h4 id="return-values-50">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address[]</td>
<td>array An array of contract addresses</td>
</tr>
</tbody>
</table>
<h3 id="gettgewithlockedtokenslist">getTgeWithLockedTokensList</h3>
<pre><code class="solidity language-solidity">function getTgeWithLockedTokensList() external view returns (address[])</code></pre>
<p><em>This method returns the list of addresses of all TGE contracts ever deployed for this token and having active token transfer restrictions.</em></p>
<h4 id="return-values-51">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address[]</td>
<td>array An array of contract addresses</td>
</tr>
</tbody>
</table>
<h3 id="lasttge">lastTGE</h3>
<pre><code class="solidity language-solidity">function lastTGE() external view returns (address)</code></pre>
<p><em>This method returns the address of the last conducted TGE for this token. Sorting is based on the starting block of the TGE, not the ending block (i.e., even if an earlier TGE contract is still active and the most recent one by creation time has already ended, the method will still return the address of the most recent contract).</em></p>
<h4 id="return-values-52">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address</td>
<td>address The contract address</td>
</tr>
</tbody>
</table>
<h3 id="gettotaltgevestedtokens">getTotalTGEVestedTokens</h3>
<pre><code class="solidity language-solidity">function getTotalTGEVestedTokens() public view returns (uint256)</code></pre>
<p><em>This method returns the accumulated value stored in the contract's memory, which represents the number of token units that are in vesting at the time of the request.</em></p>
<h4 id="return-values-53">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 The sum of tokens in vesting</td>
</tr>
</tbody>
</table>
<h3 id="gettotalprotocolfeereserved">getTotalProtocolFeeReserved</h3>
<pre><code class="solidity language-solidity">function getTotalProtocolFeeReserved() public view returns (uint256)</code></pre>
<p><em>This method returns the accumulated value stored in the contract's memory, which represents the number of token units that are reserved and should be issued and sent as the contract's fee.</em></p>
<h4 id="return-values-54">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 The sum of tokens for the fee</td>
</tr>
</tbody>
</table>
<h3 id="totalsupplywithreserves">totalSupplyWithReserves</h3>
<pre><code class="solidity language-solidity">function totalSupplyWithReserves() public view returns (uint256)</code></pre>
<p><em>This method calculates the total supply for the token taking into account the reserved but not yet issued units (for vesting and protocol fee).</em></p>
<h4 id="return-values-55">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 The sum of reserved tokens</td>
</tr>
</tbody>
</table>
<h3 id="iserc1155">isERC1155</h3>
<pre><code class="solidity language-solidity">function isERC1155() public pure returns (bool)</code></pre>
<h3 id="_transfer">_transfer</h3>
<pre><code class="solidity language-solidity">function _transfer(address from, address to, uint256 amount) internal</code></pre>
<p>Overriding the transfer method of the ERC20 token contract.</p>
<p><em>When tokens are being transferred, a check is performed to ensure that the sender's balance has a sufficient amount of tokens that are not locked up. This is a stricter condition compared to the normal balance check.
Each such transaction also triggers the check of all TGE contracts for the end of lockup and removes such contracts from the tgeWithLockedTokensList.</em></p>
<h4 id="parameters-111">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td>address</td>
<td>The address of the sender</td>
</tr>
<tr>
<td>to</td>
<td>address</td>
<td>The address of the recipient</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>Amount of tokens</td>
</tr>
</tbody>
</table>
<h3 id="_aftertokentransfer">_afterTokenTransfer</h3>
<pre><code class="solidity language-solidity">function _afterTokenTransfer(address from, address to, uint256 amount) internal</code></pre>
<p><em>Hook that is called after any transfer of tokens. This includes
minting and burning.</em></p>
<h3 id="transfer">transfer</h3>
<pre><code class="solidity language-solidity">function transfer(address to, uint256 amount) public returns (bool)</code></pre>
<h3 id="transferfrom">transferFrom</h3>
<pre><code class="solidity language-solidity">function transferFrom(address from, address to, uint256 amount) public returns (bool)</code></pre>
<h3 id="_mint">_mint</h3>
<pre><code class="solidity language-solidity">function _mint(address account, uint256 amount) internal</code></pre>
<p><em>Creates <code>amount</code> tokens and assigns them to <code>account</code>, increasing
the total supply.</em></p>
<h3 id="_burn">_burn</h3>
<pre><code class="solidity language-solidity">function _burn(address account, uint256 amount) internal</code></pre>
<p>Burning a specified amount of tokens that are held in the account's balance</p>
<p><em>Burning a specified amount of units of the token from the specified account.</em></p>
<h4 id="parameters-112">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The address from which tokens are deducted for destruction</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens to be destroyed</td>
</tr>
</tbody>
</table>
<h3 id="updatetgewithlockedtokenslist">updateTgeWithLockedTokensList</h3>
<pre><code class="solidity language-solidity">function updateTgeWithLockedTokensList() private</code></pre>
<p>Update the list of TGEs with locked tokens</p>
<p><em>It is crucial to keep this list up to date to have accurate information at any given time on how much of their token balance each user can dispose of, taking into account the locks imposed by the TGEs in which the user participated.</em></p>
<h3 id="onlypool-2">onlyPool</h3>
<pre><code class="solidity language-solidity">modifier onlyPool()</code></pre>
<p>Modifier that allows the method to be called only by the Pool contract.</p>
<h3 id="onlytgefactory-1">onlyTGEFactory</h3>
<pre><code class="solidity language-solidity">modifier onlyTGEFactory()</code></pre>
<p>Modifier that allows the method to be called only by the TGEFactory contract.</p>
<h3 id="onlytge-1">onlyTGE</h3>
<pre><code class="solidity language-solidity">modifier onlyTGE()</code></pre>
<p>Modifier that allows the method to be called only by the TGE contract.</p>
<h3 id="onlytgeorvesting">onlyTGEOrVesting</h3>
<pre><code class="solidity language-solidity">modifier onlyTGEOrVesting()</code></pre>
<p>Modifier that allows the method to be called only by the TGE or Vesting contract.</p>
<h3 id="whenpoolnotpaused-2">whenPoolNotPaused</h3>
<pre><code class="solidity language-solidity">modifier whenPoolNotPaused()</code></pre>
<p>Modifier that allows the method to be called only if the Pool contract is not paused.</p>
<h2 id="tokenerc1155">TokenERC1155</h2>
<p><em>An expanded ERC20 contract, based on which tokens of various types are issued. At the moment, the protocol provides for 2 types of tokens: Governance, which must be created simultaneously with the pool, existing for the pool only in the singular and participating in voting, and Preference, which may be several for one pool and which do not participate in voting in any way.</em></p>
<h3 id="service-4">service</h3>
<pre><code class="solidity language-solidity">contract IService service</code></pre>
<p><em>The address of the Service contract</em></p>
<h3 id="symbol-1">symbol</h3>
<pre><code class="solidity language-solidity">string symbol</code></pre>
<p><em>The token symbol or ticker for listing</em></p>
<h3 id="_tokenuris">_tokenURIs</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; string) _tokenURIs</code></pre>
<p><em>Mapping storing the URI metadata for each collection of the token</em></p>
<h3 id="cap-1">cap</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; uint256) cap</code></pre>
<p><em>Mapping storing the maximum caps for each collection of ERC1155 token</em></p>
<h3 id="lasttokenid">lastTokenId</h3>
<pre><code class="solidity language-solidity">uint256 lastTokenId</code></pre>
<p><em>The identifier (sequential number) of the token collection that was created last</em></p>
<h3 id="pool-2">pool</h3>
<pre><code class="solidity language-solidity">address pool</code></pre>
<p><em>The address of the pool contract that owns the token</em></p>
<h3 id="tokentype-1">tokenType</h3>
<pre><code class="solidity language-solidity">enum IToken.TokenType tokenType</code></pre>
<p>The digital code of the token type</p>
<p><em>In the current version, ERC1155 tokens can only have the code "2", which corresponds to the Preference token type.</em></p>
<h3 id="name">name</h3>
<pre><code class="solidity language-solidity">string name</code></pre>
<p><em>Preference token name</em></p>
<h3 id="description-1">description</h3>
<pre><code class="solidity language-solidity">string description</code></pre>
<p><em>Preference token description, allows up to 5000 characters, for others - ""</em></p>
<h3 id="tgelist-1">tgeList</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; address[]) tgeList</code></pre>
<p>All TGEs associated with this token</p>
<p><em>A list of TGE contract addresses that have been launched to distribute collections of this token. The collection ID serves as the key for this mapping.</em></p>
<h3 id="totalvested-2">totalVested</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; uint256) totalVested</code></pre>
<p><em>Mapping storing the amounts of tokens in vesting for each collection of this token</em></p>
<h3 id="tgewithlockedtokenslist-1">tgeWithLockedTokensList</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; address[]) tgeWithLockedTokensList</code></pre>
<p><em>Mapping storing lists of TGEs with active token lockups for each collection of this token</em></p>
<h3 id="totalprotocolfeereserved-1">totalProtocolFeeReserved</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; uint256) totalProtocolFeeReserved</code></pre>
<p><em>Mapping storing the amounts of tokens reserved as protocol fees for each collection of this token</em></p>
<h3 id="constructor-7">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<p>Contract constructor.</p>
<p><em>This contract uses OpenZeppelin upgrades and has no need for a constructor function.
The constructor is replaced with an initializer function.
This method disables the initializer feature of the OpenZeppelin upgrades plugin, preventing the initializer methods from being misused.</em></p>
<h3 id="initialize-8">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(contract IService _service, address _pool, struct IToken.TokenInfo _info, address _primaryTGE) external</code></pre>
<p><em>Token creation, can only be started once. At the same time, the TGE contract, which sells the created token, is necessarily simultaneously deployed and receives an entry in the Registry. For Preference tokens, you can set an arbitrary value of the Name field.</em></p>
<h4 id="parameters-113">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_service</td>
<td>contract IService</td>
<td>The address of the Service contract.</td>
</tr>
<tr>
<td>_pool</td>
<td>address</td>
<td>The address of the pool contract.</td>
</tr>
<tr>
<td>_info</td>
<td>struct IToken.TokenInfo</td>
<td>The parameters of the token, including its type, in the form of a structure described in the TokenInfo method.</td>
</tr>
<tr>
<td>_primaryTGE</td>
<td>address</td>
<td>The address of the primary TGE for this token.</td>
</tr>
</tbody>
</table>
<h3 id="mint-1">mint</h3>
<pre><code class="solidity language-solidity">function mint(address to, uint256 tokenId, uint256 amount) external</code></pre>
<p><em>Minting of new tokens. Only the TGE or Vesting contract can mint tokens, there is no other way to get an additional issue. If the user who is being minted does not have tokens, they are sent to delegation on his behalf.</em></p>
<h4 id="parameters-114">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td>address</td>
<td>The address of the account for which new token units are being minted.</td>
</tr>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens being minted.</td>
</tr>
</tbody>
</table>
<h3 id="burn-1">burn</h3>
<pre><code class="solidity language-solidity">function burn(address from, uint256 tokenId, uint256 amount) public</code></pre>
<p><em>Method for burning tokens. It can be called by both token owners and TGE contracts to burn the returned tokens during redeeming.</em></p>
<h4 id="parameters-115">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td>address</td>
<td>The account address.</td>
</tr>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens being burned.</td>
</tr>
</tbody>
</table>
<h3 id="addtge-1">addTGE</h3>
<pre><code class="solidity language-solidity">function addTGE(address tge, uint256 tokenId) external</code></pre>
<p><em>This method adds the TGE contract address to the TGEList of the specified token collection.</em></p>
<h4 id="parameters-116">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>The TGE address.</td>
</tr>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h3 id="settgevestedtokens-1">setTGEVestedTokens</h3>
<pre><code class="solidity language-solidity">function setTGEVestedTokens(uint256 amount, uint256 tokenId) external</code></pre>
<p><em>This method modifies the number of token units that are vested and reserved for claiming by users.</em></p>
<h4 id="parameters-117">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens.</td>
</tr>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h3 id="settokenidcap">setTokenIdCap</h3>
<pre><code class="solidity language-solidity">function setTokenIdCap(uint256 _tokenId, uint256 _cap) external</code></pre>
<p><em>This method irreversibly sets the emission cap for each of the created token collections.</em></p>
<h4 id="parameters-118">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
<tr>
<td>_cap</td>
<td>uint256</td>
<td>The maximum emission cap in token units.</td>
</tr>
</tbody>
</table>
<h3 id="setprotocolfeereserved-1">setProtocolFeeReserved</h3>
<pre><code class="solidity language-solidity">function setProtocolFeeReserved(uint256 amount, uint256 tokenId) external</code></pre>
<p><em>This method modifies the number of token units that should be used as protocol fees.</em></p>
<h4 id="parameters-119">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens.</td>
</tr>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h3 id="seturi">setURI</h3>
<pre><code class="solidity language-solidity">function setURI(uint256 tokenId, string tokenURI) external</code></pre>
<p><em>This method sets the metadata URI for each of the token collections.</em></p>
<h4 id="parameters-120">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
<tr>
<td>tokenURI</td>
<td>string</td>
<td>The metadata URI.</td>
</tr>
</tbody>
</table>
<h3 id="decimals-1">decimals</h3>
<pre><code class="solidity language-solidity">function decimals() public pure returns (uint8)</code></pre>
<p><em>This method is needed for compatibility with other protocol contracts to optimize algorithms. It always returns 0.</em></p>
<h4 id="return-values-56">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint8</td>
<td>uint8 Decimals (always 0)</td>
</tr>
</tbody>
</table>
<h3 id="unlockedbalanceof-1">unlockedBalanceOf</h3>
<pre><code class="solidity language-solidity">function unlockedBalanceOf(address account, uint256 tokenId) public view returns (uint256)</code></pre>
<p><em>The given getter returns the total balance of the address that is not locked for transfer, taking into account all the TGEs with which this token collection was distributed.
It calculates the difference between the actual balance of the account and its locked portion. The calculation is performed for the specified token collection.</em></p>
<h4 id="parameters-121">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The account address.</td>
</tr>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-57">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 The unlocked balance of the account.</td>
</tr>
</tbody>
</table>
<h3 id="isprimarytgesuccessful-1">isPrimaryTGESuccessful</h3>
<pre><code class="solidity language-solidity">function isPrimaryTGESuccessful(uint256 _tokenId) external view returns (bool)</code></pre>
<p><em>This method indicates whether a successful TGE has been conducted for the given token collection. It is sufficient to check the first event from the list of all TGEs.</em></p>
<h4 id="parameters-122">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-58">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>bool Whether any TGE is successful.</td>
</tr>
</tbody>
</table>
<h3 id="gettgelist-1">getTGEList</h3>
<pre><code class="solidity language-solidity">function getTGEList(uint256 tokenId) external view returns (address[])</code></pre>
<p><em>This method returns the list of addresses of all TGE contracts that have ever been deployed for the specified token collection.</em></p>
<h4 id="parameters-123">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-59">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address[]</td>
<td>array An array of contract addresses.</td>
</tr>
</tbody>
</table>
<h3 id="gettgewithlockedtokenslist-1">getTgeWithLockedTokensList</h3>
<pre><code class="solidity language-solidity">function getTgeWithLockedTokensList(uint256 tokenId) external view returns (address[])</code></pre>
<p><em>This method returns the list of addresses of all TGE contracts that have ever been deployed for the specified token collection and have active transfer restrictions.</em></p>
<h4 id="parameters-124">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-60">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address[]</td>
<td>array An array of contract addresses.</td>
</tr>
</tbody>
</table>
<h3 id="lasttge-1">lastTGE</h3>
<pre><code class="solidity language-solidity">function lastTGE(uint256 tokenId) external view returns (address)</code></pre>
<p><em>This method returns the address of the latest TGE contract for the given token collection. Sorting is based on the block of the TGE start, not the end block (i.e., even if an earlier TGE contract is still active while the latest one by creation time has already ended, this method will return the address of the latest contract).</em></p>
<h4 id="parameters-125">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-61">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address</td>
<td>address The TGE contract address.</td>
</tr>
</tbody>
</table>
<h3 id="gettotaltgevestedtokens-1">getTotalTGEVestedTokens</h3>
<pre><code class="solidity language-solidity">function getTotalTGEVestedTokens(uint256 tokenId) public view returns (uint256)</code></pre>
<p><em>This method returns the accumulated value stored in the contract's memory, which represents the number of token units from the specified collection that are vested at the time of the request.</em></p>
<h4 id="parameters-126">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-62">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 The total number of vested tokens.</td>
</tr>
</tbody>
</table>
<h3 id="gettotalprotocolfeereserved-1">getTotalProtocolFeeReserved</h3>
<pre><code class="solidity language-solidity">function getTotalProtocolFeeReserved(uint256 tokenId) public view returns (uint256)</code></pre>
<p><em>This method calculates the total supply for the token, taking into account the reserved but not yet minted token units (for vesting and protocol fee).</em></p>
<h4 id="parameters-127">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-63">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 The total supply with reserves.</td>
</tr>
</tbody>
</table>
<h3 id="totalsupplywithreserves-1">totalSupplyWithReserves</h3>
<pre><code class="solidity language-solidity">function totalSupplyWithReserves(uint256 tokenId) public view returns (uint256)</code></pre>
<p><em>This method calculates the total supply for an ERC1155 token collection, taking into account the reserved but not yet minted token units (for vesting and protocol fee).</em></p>
<h4 id="parameters-128">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-64">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 The total supply of the token collection with reserves.</td>
</tr>
</tbody>
</table>
<h3 id="uri">uri</h3>
<pre><code class="solidity language-solidity">function uri(uint256 tokenId) public view returns (string)</code></pre>
<p><em>This getter allows retrieving the stored metadata URI for the specified ERC1155 token collection in the contract.</em></p>
<h4 id="parameters-129">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-65">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>string</td>
<td>uint256 The metadata URI for the collection.</td>
</tr>
</tbody>
</table>
<h3 id="iserc1155-1">isERC1155</h3>
<pre><code class="solidity language-solidity">function isERC1155() external pure returns (bool)</code></pre>
<h3 id="geturilist">getURIList</h3>
<pre><code class="solidity language-solidity">function getURIList(uint256 limit, uint256 offset) external view returns (string[])</code></pre>
<h3 id="_transfer-1">_transfer</h3>
<pre><code class="solidity language-solidity">function _transfer(address from, address to, uint256 tokenId, uint256 amount) internal</code></pre>
<p>Simple transfer for ERC1155 tokens.</p>
<p><em>This method is used to transfer a specified amount of token units of the specified tokenId token collection of the ERC1155 type. The _beforeTokenTransfer validation scenario is applied before sending the tokens.</em></p>
<h4 id="parameters-130">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td>address</td>
<td>The address of the sender.</td>
</tr>
<tr>
<td>to</td>
<td>address</td>
<td>The address of the recipient.</td>
</tr>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The token collection of the ERC1155 contract.</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens.</td>
</tr>
</tbody>
</table>
<h3 id="transfer-1">transfer</h3>
<pre><code class="solidity language-solidity">function transfer(address from, address to, uint256 tokenId, uint256 amount) external</code></pre>
<h3 id="_beforetokentransfer">_beforeTokenTransfer</h3>
<pre><code class="solidity language-solidity">function _beforeTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal</code></pre>
<p>Special hook for validating ERC1155 transfers.</p>
<p><em>It is used to update the list of TGEs with an active lockup for the token units being transferred in an optimized way, while also checking the availability of unlocked balance for the transfer.
The set of parameters for this hook is comprehensive to be used for all ERC1155 methods related to token transfers between accounts.</em></p>
<h4 id="parameters-131">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>operator</td>
<td>address</td>
<td>The potential initiator of the TransferFrom transaction to whom the account entrusted their tokens.</td>
</tr>
<tr>
<td>from</td>
<td>address</td>
<td>The address of the sender.</td>
</tr>
<tr>
<td>to</td>
<td>address</td>
<td>The address of the recipient.</td>
</tr>
<tr>
<td>ids</td>
<td>uint256[]</td>
<td>The list of ERC1155 token collection IDs that are being transferred to another account.</td>
</tr>
<tr>
<td>amounts</td>
<td>uint256[]</td>
<td>The list of corresponding amounts of token units.</td>
</tr>
<tr>
<td>data</td>
<td>bytes</td>
<td>Additional calldata attached to the transaction.</td>
</tr>
</tbody>
</table>
<h3 id="_seturi">_setURI</h3>
<pre><code class="solidity language-solidity">function _setURI(uint256 tokenId, string tokenURI) internal</code></pre>
<p><em>Set the metadata URI source for the token collection.</em></p>
<h4 id="parameters-132">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The identifier of the ERC1155 token collection.</td>
</tr>
<tr>
<td>tokenURI</td>
<td>string</td>
<td>The URI string specifying the metadata source.</td>
</tr>
</tbody>
</table>
<h3 id="_updatetgewithlockedtokenslist">_updateTgeWithLockedTokensList</h3>
<pre><code class="solidity language-solidity">function _updateTgeWithLockedTokensList(uint256 tokenId) private</code></pre>
<p>Update the list of TGEs with locked tokens.</p>
<p><em>It is crucial to keep this list up to date to have accurate information on how much of their token balance each user can dispose of, taking into account the locks imposed by TGEs in which the user participated.
Due to the nature of ERC1155, this method requires an additional argument specifying the token collection "tokenId". When transferring tokens of such collection, all TGEs related to the distribution of tokens from this collection will be checked.</em></p>
<h4 id="parameters-133">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>ERC1155 token collection identifier</td>
</tr>
</tbody>
</table>
<h3 id="onlypool-3">onlyPool</h3>
<pre><code class="solidity language-solidity">modifier onlyPool()</code></pre>
<p>Modifier that allows the method to be called only by the Pool contract.</p>
<h3 id="onlytgefactory-2">onlyTGEFactory</h3>
<pre><code class="solidity language-solidity">modifier onlyTGEFactory()</code></pre>
<p>Modifier that allows the method to be called only by the TGEFactory contract.</p>
<h3 id="onlytge-2">onlyTGE</h3>
<pre><code class="solidity language-solidity">modifier onlyTGE()</code></pre>
<p>Modifier that allows the method to be called only by the TGE contract.</p>
<h3 id="onlytgeorvesting-1">onlyTGEOrVesting</h3>
<pre><code class="solidity language-solidity">modifier onlyTGEOrVesting()</code></pre>
<p>Modifier that allows the method to be called only by the TGE or Vesting contract.</p>
<h3 id="whenpoolnotpaused-3">whenPoolNotPaused</h3>
<pre><code class="solidity language-solidity">modifier whenPoolNotPaused()</code></pre>
<p>Modifier that allows the method to be called only if the Pool contract is not paused.</p>
<h2 id="tokenfactory-1">TokenFactory</h2>
<p><em>A factory for token contracts, utilizing the Beacon Proxy pattern for creating new contracts. 
Each new contract is a "proxy" pointing to a "beacon" that stores the implementation logic.
This enables cheaper creation of new contracts and easier updating of all contracts at once.
The contract can also be upgraded, meaning the contract's logic can be replaced while retaining the same contract address and state variables.</em></p>
<h3 id="service-5">service</h3>
<pre><code class="solidity language-solidity">contract IService service</code></pre>
<p>Service contract</p>
<h3 id="onlytgefactory-3">onlyTGEFactory</h3>
<pre><code class="solidity language-solidity">modifier onlyTGEFactory()</code></pre>
<p>Modifier restricting function call to TGEFactory contract only</p>
<p><em>Throws an exception if the caller is not the TGEFactory contract's address</em></p>
<h3 id="constructor-8">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<p>Contract constructor</p>
<p><em>Disables the usage of initializers</em></p>
<h3 id="initialize-9">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(contract IService service_) external</code></pre>
<p><em>Initializer function, can only be called once</em></p>
<h4 id="parameters-134">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>service_</td>
<td>contract IService</td>
<td>Address of the service contract</td>
</tr>
</tbody>
</table>
<h3 id="createtoken">createToken</h3>
<pre><code class="solidity language-solidity">function createToken(address pool, struct IToken.TokenInfo info, address primaryTGE) external returns (address token)</code></pre>
<p><em>Creates a token contract</em></p>
<h4 id="parameters-135">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the pool</td>
</tr>
<tr>
<td>info</td>
<td>struct IToken.TokenInfo</td>
<td>Token information</td>
</tr>
<tr>
<td>primaryTGE</td>
<td>address</td>
<td>Address of the primary TGE</td>
</tr>
</tbody>
</table>
<h4 id="return-values-66">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>token</td>
<td>address</td>
<td>Token contract</td>
</tr>
</tbody>
</table>
<h3 id="createtokenerc1155">createTokenERC1155</h3>
<pre><code class="solidity language-solidity">function createTokenERC1155(address pool, struct IToken.TokenInfo info, address primaryTGE) external returns (address token)</code></pre>
<p><em>Creates a ERC1155 token contract</em></p>
<h4 id="parameters-136">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Address of the pool</td>
</tr>
<tr>
<td>info</td>
<td>struct IToken.TokenInfo</td>
<td>Token information</td>
</tr>
<tr>
<td>primaryTGE</td>
<td>address</td>
<td>Address of the primary TGE</td>
</tr>
</tbody>
</table>
<h4 id="return-values-67">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>token</td>
<td>address</td>
<td>Token contract</td>
</tr>
</tbody>
</table>
<h2 id="vesting-2">Vesting</h2>
<p>The Vesting contract exists in a single instance and helps manage the vesting processes for all successful TGEs.</p>
<p><em>The vesting setup is performed by passing a value as one of the fields of the TGEInfo structure called "vestingParams", which is a structure of IVesting.VestingParams. This set of settings allows you to specify:
    - what portion of the tokens will be released and directed to the buyer's wallet within the purchase transaction (using the TGE:purchase method);
    - what portion of the tokens will be available for claim after the cliff period and the duration of this period;
    - what percentage of the remaining tokens will be distributed equally over equal time intervals (as well as the number and duration of these intervals).
    Any of these fields can accept zero values, for example, you can set the distribution of tokens without a cliff period or, conversely, split the receipt of values into two parts (immediately and after some time), without specifying time intervals.
    <a href="https://github.com/dev">@dev</a> For each TGE, a list of Resolvers can be assigned, i.e., addresses that can stop the vesting program for a specific user. 
    The list of resolvers is immutable for each individual TGE and is set at the time of its launch (it can be stored in the proposal data for creating the TGE beforehand).</em></p>
<h3 id="denom-2">DENOM</h3>
<pre><code class="solidity language-solidity">uint256 DENOM</code></pre>
<p>Denominator for shares (such as thresholds)</p>
<p><em>The constant Service.sol:DENOM is used to work with percentage values of QuorumThreshold and DecisionThreshold thresholds, as well as for calculating the ProtocolTokenFee. In this version, it is equal to 1,000,000, for clarity stored as 100 * 10 ^ 4.
    10^4 corresponds to one percent, and 100 * 10^4 corresponds to one hundred percent.
    The value of 12.3456% will be written as 123,456, and 78.9% as 789,000.
    This notation allows specifying ratios with an accuracy of up to four decimal places in percentage notation (six decimal places in decimal notation).
    When working with the CompanyDAO frontend, the application scripts automatically convert the familiar percentage notation into the required format. When using the contracts independently, this feature of value notation should be taken into account.</em></p>
<h3 id="registry-3">registry</h3>
<pre><code class="solidity language-solidity">contract IRegistry registry</code></pre>
<p>Registry contract address</p>
<h3 id="totalvested-3">totalVested</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; uint256) totalVested</code></pre>
<p>Mapping that stores the total amount of tokens locked in vesting for each conducted TGE.</p>
<p><em>Claiming tokens does not modify these data; they are used to calculate the amount of tokens that can be claimed by a specific address and to determine the total amount of tokens in vesting for a given account.
In the event of vesting cancellation for a specific address in any TGE, the value under the TGE address key is decreased by the full amount of tokens locked in vesting for that address.</em></p>
<h3 id="vested">vested</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; mapping(address =&gt; uint256)) vested</code></pre>
<p>Mapping (tge, account) to amount of tokens vested to that account in TGE</p>
<p><em>The vesting contract does not store tokens, but it contains records of which address is entitled to what amount of tokens for which TGE when the conditions set in the settings are met. This means that minting these tokens only occurs when the owner of the address requests them, prior to that, they are not included in totalSupply or balances. No record in Vesting can affect the vote calculation for Governance.</em></p>
<h3 id="claimed">claimed</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; mapping(address =&gt; uint256)) claimed</code></pre>
<p>Mapping that stores the total amount of tokens vested by a specific address for a given TGE.</p>
<p><em>This parameter increases every time a successful transaction is made to the Claim method by an address.</em></p>
<h3 id="claimtvlreached">claimTVLReached</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; bool) claimTVLReached</code></pre>
<p>Mapping of flags indicating whether the TVL threshold set in the TGE conditions has been reached by the pool.</p>
<p><em>It is one of the two conditions under which users can claim tokens reserved for them under the vesting program.</em></p>
<h3 id="resolved">resolved</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; mapping(address =&gt; uint256)) resolved</code></pre>
<p>Mapping that shows the amount of tokens that will not be transferred to the user during claiming due to the cancellation of vesting by a resolver.</p>
<h3 id="vested-1">Vested</h3>
<pre><code class="solidity language-solidity">event Vested(address tge, address account, uint256 amount)</code></pre>
<p><em>This event is emitted when new token units are vested due to token purchase.</em></p>
<h4 id="parameters-137">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE contract address</td>
</tr>
<tr>
<td>account</td>
<td>address</td>
<td>Account address</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>Amount of tokens vested for the account</td>
</tr>
</tbody>
</table>
<h3 id="claimed-1">Claimed</h3>
<pre><code class="solidity language-solidity">event Claimed(address tge, address account, uint256 amount)</code></pre>
<p><em>This event is emitted for each token claiming by users.</em></p>
<h4 id="parameters-138">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE contract address</td>
</tr>
<tr>
<td>account</td>
<td>address</td>
<td>Account address that requested the token claiming</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>Amount of claimed tokens</td>
</tr>
</tbody>
</table>
<h3 id="cancelled">Cancelled</h3>
<pre><code class="solidity language-solidity">event Cancelled(address tge, address account, uint256 amount)</code></pre>
<p><em>This event is emitted when vesting is canceled for a specific account and TGE.</em></p>
<h4 id="parameters-139">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE contract address</td>
</tr>
<tr>
<td>account</td>
<td>address</td>
<td>Account address</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>Amount of tokens that will not be distributed to this address due to the cancellation</td>
</tr>
</tbody>
</table>
<h3 id="onlytge-3">onlyTGE</h3>
<pre><code class="solidity language-solidity">modifier onlyTGE()</code></pre>
<p>Modifier allows the method to be called only by the TGE contract.</p>
<p><em>This modifier is commonly used for calling the <code>vest</code> method, which registers the arrival of new token units into vesting as a result of a successful <code>purchase</code> method call in the TGE contract.</em></p>
<h3 id="onlymanager-3">onlyManager</h3>
<pre><code class="solidity language-solidity">modifier onlyManager()</code></pre>
<p>Modifier allows the method to be called only by an account that has the role of <code>SERVICE_MANAGER</code> in the Service contract.</p>
<p><em>It restricts access to certain privileged actions that are reserved for the manager.</em></p>
<h3 id="onlyresolverortge">onlyResolverOrTGE</h3>
<pre><code class="solidity language-solidity">modifier onlyResolverOrTGE(address tge)</code></pre>
<p>Modifier allows the method to be called only by an account whose address is specified in the list of resolvers for a given TGE.</p>
<h3 id="constructor-9">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<p>Contract constructor.</p>
<p><em>This contract uses OpenZeppelin upgrades and has no need for a constructor function.
The constructor is replaced with an initializer function.
This method disables the initializer feature of the OpenZeppelin upgrades plugin, preventing the initializer methods from being misused.</em></p>
<h3 id="initialize-10">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(contract IRegistry registry_) external</code></pre>
<p>Contract initializer</p>
<p><em>This method replaces the constructor for upgradeable contracts. Additionally, it sets the address of the Registry contract in the contract's storage.</em></p>
<h4 id="parameters-140">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>registry_</td>
<td>contract IRegistry</td>
<td>Protocol registry address</td>
</tr>
</tbody>
</table>
<h3 id="vest">vest</h3>
<pre><code class="solidity language-solidity">function vest(address to, uint256 amount) external</code></pre>
<p>Method for increasing the token balance in vesting for a specific TGE contract.</p>
<p><em>This method is called only by the TGE contract and results in the creation of a new entry or an increase in the existing value in the vested mapping for the TGE key and the specified account. After this, the account is reserved the ability to mint and receive new token units in case the conditions specified in the vesting program for this TGE are met.</em></p>
<h4 id="parameters-141">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td>address</td>
<td>Account address that received the vested tokens</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>Amount of tokens to vest</td>
</tr>
</tbody>
</table>
<h3 id="setclaimtvlreached">setClaimTVLReached</h3>
<pre><code class="solidity language-solidity">function setClaimTVLReached(address tge) external</code></pre>
<p>Method for recording the occurrence of one of two conditions for token unlocking.</p>
<p><em>This method can only be called by the address with the SERVICE_MANAGER role in the Service contract. It is a trusted way to load data into the source of truth about the TVL events achieved by the pool, as specified in the parameters of the vesting program.</em></p>
<h4 id="parameters-142">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE contract address</td>
</tr>
</tbody>
</table>
<h3 id="cancel">cancel</h3>
<pre><code class="solidity language-solidity">function cancel(address tge, address account) external</code></pre>
<p>Cancels vesting for the specified account and TGE contract addresses.</p>
<p><em>Calling this method is only possible by the address specified in the resolvers list for the specific TGE, and it leads to resetting the token balance in vesting for the specified address, depriving it of the ability to make successful token claiming within the specified TGE.</em></p>
<h4 id="parameters-143">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE contract address</td>
</tr>
<tr>
<td>account</td>
<td>address</td>
<td>Account address</td>
</tr>
</tbody>
</table>
<h3 id="claim">claim</h3>
<pre><code class="solidity language-solidity">function claim(address tge) external</code></pre>
<p>Method to issue and transfer unlocked tokens to the transaction sender's address.</p>
<p><em>This method is executed with the specified TGE, for which the currently unlocked token volume is calculated. Calling the method results in the issuance and transfer of the entire calculated token volume to the sender's address.</em></p>
<h4 id="parameters-144">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE contract address</td>
</tr>
</tbody>
</table>
<h3 id="vestingparams">vestingParams</h3>
<pre><code class="solidity language-solidity">function vestingParams(address tge) public view returns (struct IVesting.VestingParams)</code></pre>
<p>This method returns the vesting parameters specified for a specific TGE.</p>
<h4 id="parameters-145">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE contract address</td>
</tr>
</tbody>
</table>
<h4 id="return-values-68">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>struct IVesting.VestingParams</td>
<td>VestingParams Vesting settings</td>
</tr>
</tbody>
</table>
<h3 id="validateparams">validateParams</h3>
<pre><code class="solidity language-solidity">function validateParams(struct IVesting.VestingParams params) public pure returns (bool)</code></pre>
<p>This method validates the vesting program parameters proposed for use in the created TGE contract.</p>
<h4 id="parameters-146">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>params</td>
<td>struct IVesting.VestingParams</td>
<td>Vesting program parameters</td>
</tr>
</tbody>
</table>
<h4 id="return-values-69">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>bool True if params are valid (reverts otherwise)</td>
</tr>
</tbody>
</table>
<h3 id="unlockedbalanceof-2">unlockedBalanceOf</h3>
<pre><code class="solidity language-solidity">function unlockedBalanceOf(address tge, address account) public view returns (uint256)</code></pre>
<p>This method returns the number of token units that have been unlocked for a specific account within the vesting program of a particular TGE.</p>
<p><em>The returned value is the total sum of all quantities after all token unlocks that have occurred for this account within this TGE. In other words, claimed tokens are also part of this response.</em></p>
<h4 id="parameters-147">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE contract address</td>
</tr>
<tr>
<td>account</td>
<td>address</td>
<td>Account address</td>
</tr>
</tbody>
</table>
<h4 id="return-values-70">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 Number of unlocked token units</td>
</tr>
</tbody>
</table>
<h3 id="claimablebalanceof">claimableBalanceOf</h3>
<pre><code class="solidity language-solidity">function claimableBalanceOf(address tge, address account) public view returns (uint256)</code></pre>
<p>This method returns the currently available amount of token units that an account can claim within the specified TGE.</p>
<p><em>This method takes into account previous claimings made by the account.</em></p>
<h4 id="parameters-148">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE contract address</td>
</tr>
<tr>
<td>account</td>
<td>address</td>
<td>Account address</td>
</tr>
</tbody>
</table>
<h4 id="return-values-71">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uin256 Number of claimable token units</td>
</tr>
</tbody>
</table>
<h3 id="vestedbalanceof-1">vestedBalanceOf</h3>
<pre><code class="solidity language-solidity">function vestedBalanceOf(address tge, address account) public view returns (uint256)</code></pre>
<p>This method shows the remaining tokens that are still vested for a given address.</p>
<p><em>This method shows both still locked token units and already unlocked units ready for claiming.</em></p>
<h4 id="parameters-149">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tge</td>
<td>address</td>
<td>TGE contract address</td>
</tr>
<tr>
<td>account</td>
<td>address</td>
<td>Account address</td>
</tr>
</tbody>
</table>
<h4 id="return-values-72">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>uint256 Number of token units vested</td>
</tr>
</tbody>
</table>
<h2 id="governancesettings">GovernanceSettings</h2>
<p>This module is responsible for storing, validating, and applying Governance settings, and it inherits from the GovernorProposals contract.</p>
<p><em>This contract houses one of the most important structures of the protocol called GovernanceSettingsSet. It is used to represent various numerical parameters that universally and comprehensively describe the voting process. The module includes methods for formal data validation, which is proposed to be stored using this structure.</em></p>
<h3 id="denom-3">DENOM</h3>
<pre><code class="solidity language-solidity">uint256 DENOM</code></pre>
<p>Denominator for shares (such as thresholds)</p>
<p><em>The constant Service.sol:DENOM is used to work with percentage values of QuorumThreshold and DecisionThreshold thresholds, as well as for calculating the ProtocolTokenFee. In this version, it is equal to 1,000,000, for clarity stored as 100 * 10 ^ 4.
    10^4 corresponds to one percent, and 100 * 10^4 corresponds to one hundred percent.
    The value of 12.3456% will be written as 123,456, and 78.9% as 789,000.
    This notation allows specifying ratios with an accuracy of up to four decimal places in percentage notation (six decimal places in decimal notation).
    When working with the CompanyDAO frontend, the application scripts automatically convert the familiar percentage notation into the required format. When using the contracts independently, this feature of value notation should be taken into account.</em></p>
<h3 id="proposalthreshold">proposalThreshold</h3>
<pre><code class="solidity language-solidity">uint256 proposalThreshold</code></pre>
<p>The minimum amount of votes required to create a proposal</p>
<p><em>The proposal threshold is the number of votes (i.e., tokens delegated to an address) that are minimally required to create a proposal. When calling the Pool:propose method, the contract compares the number of votes of the address with this value, and if there are insufficient tokens in the delegation, the transaction ends with a revert.
    This value is stored in the Pool contract as an integer, taking into account the "Decimals" parameter of the Governance token. In the current version, for Governance tokens, this parameter is equal to 18. That is, the 18 rightmost digits of the value represent the fractional part of the number of tokens required to create a proposal.
    Each pool can set any ProposalThreshold value in the range from 0 to the maximum value allowed by the uint256 type. The setting is made in conjunction with changing other Governance Settings either by the Owner of the pool when launching the primary TGE or during the execution of "Governance Settings" proposal transactions.</em></p>
<h3 id="quorumthreshold">quorumThreshold</h3>
<pre><code class="solidity language-solidity">uint256 quorumThreshold</code></pre>
<p>The minimum amount of votes which need to participate in the proposal in order for the proposal to be considered valid, given as a percentage of all existing votes</p>
<p><em>The quorum threshold is a percentage ratio stored in the Pool contract as an integer using the DENOM entry. It indicates the minimum share of all proposals[proposalId].vote.availableVotes that must be used in voting (regardless of whether the votes were "for" or "against", their sum matters) for the vote to be considered valid.
    Reaching the Quorum Threshold is one of several conditions required for a proposal to be accepted and executable.
    Each pool can set any QuorumThreshold value in the range from 0 to 100%. The setting is made in conjunction with changing other Governance Settings either by the Owner of the pool when launching the primary TGE or during the execution of "Governance Settings" proposal transactions.</em></p>
<h3 id="decisionthreshold">decisionThreshold</h3>
<pre><code class="solidity language-solidity">uint256 decisionThreshold</code></pre>
<p>The minimum amount of votes which are needed to approve the proposal, given as a percentage of all participating votes</p>
<p><em>The decision threshold is a percentage ratio stored in the Pool contract as an integer using the DENOM entry. It indicates the minimum share of the votes cast by users that must be cast "for" a proposal during voting for a positive decision to be made.
    The sum of all votes cast by users during voting can be calculated using the formula:
        Pool:proposals[proposalId].vote.forVotes + Pool:proposals[proposalId].vote.againstVotes
    Reaching the Decision Threshold is one of several conditions required for a proposal to be accepted and executable.
    Each pool can set any DecisionThreshold value in the range from 0 to 100%. The setting is made in conjunction with changing other Governance Settings either by the Owner of the pool when launching the primary TGE or during the execution of "Governance Settings" proposal transactions.</em></p>
<h3 id="votingduration">votingDuration</h3>
<pre><code class="solidity language-solidity">uint256 votingDuration</code></pre>
<p>The amount of time for which the proposal will remain active, given as the number of blocks which have elapsed since the creation of the proposal</p>
<h3 id="transfervaluefordelay">transferValueForDelay</h3>
<pre><code class="solidity language-solidity">uint256 transferValueForDelay</code></pre>
<p>The threshold value for a transaction which triggers the transaction execution delay</p>
<h3 id="executiondelays">executionDelays</h3>
<pre><code class="solidity language-solidity">mapping(enum IRecordsRegistry.EventType =&gt; uint256) executionDelays</code></pre>
<p>Returns transaction execution delay values for different proposal types</p>
<h3 id="votingstartdelay">votingStartDelay</h3>
<pre><code class="solidity language-solidity">uint256 votingStartDelay</code></pre>
<p>Delay before voting starts. In blocks</p>
<h3 id="__gap">__gap</h3>
<pre><code class="solidity language-solidity">uint256[49] __gap</code></pre>
<p>Storage gap (for future upgrades)</p>
<h3 id="governancesettingsset">GovernanceSettingsSet</h3>
<pre><code class="solidity language-solidity">event GovernanceSettingsSet(uint256 proposalThreshold_, uint256 quorumThreshold_, uint256 decisionThreshold_, uint256 votingDuration_, uint256 transferValueForDelay_, uint256[4] executionDelays_, uint256 votingStartDelay_)</code></pre>
<p>This event emitted only when the following values (governance settings) are set for a particular pool</p>
<p><em>The emission of this event can coincide with the purchase of a pool, the launch of an initial TGE, or the execution of a transaction prescribed by a proposal with the GovernanceSettings type.GovernanceSettings</em></p>
<h4 id="parameters-150">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalThreshold_</td>
<td>uint256</td>
<td>the proposal threshold (specified in token units with decimals taken into account)</td>
</tr>
<tr>
<td>quorumThreshold_</td>
<td>uint256</td>
<td>the quorum threshold (specified as a percentage)</td>
</tr>
<tr>
<td>decisionThreshold_</td>
<td>uint256</td>
<td>the decision threshold (specified as a percentage)</td>
</tr>
<tr>
<td>votingDuration_</td>
<td>uint256</td>
<td>the duration of the voting period (specified in blocks)</td>
</tr>
<tr>
<td>transferValueForDelay_</td>
<td>uint256</td>
<td>the minimum amount in USD for which a transfer from the pool wallet will be subject to a delay</td>
</tr>
<tr>
<td>executionDelays_</td>
<td>uint256[4]</td>
<td>execution delays specified in blocks for different types of proposals</td>
</tr>
<tr>
<td>votingStartDelay_</td>
<td>uint256</td>
<td>the delay before voting starts for newly created proposals, specified in blocks</td>
</tr>
</tbody>
</table>
<h3 id="setgovernancesettings">setGovernanceSettings</h3>
<pre><code class="solidity language-solidity">function setGovernanceSettings(struct IGovernanceSettings.NewGovernanceSettings settings) external</code></pre>
<p>Updates governance settings</p>
<h4 id="parameters-151">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>settings</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>New governance settings</td>
</tr>
</tbody>
</table>
<h3 id="_setgovernancesettings">_setGovernanceSettings</h3>
<pre><code class="solidity language-solidity">function _setGovernanceSettings(struct IGovernanceSettings.NewGovernanceSettings settings) internal</code></pre>
<p>Updates governance settings</p>
<h4 id="parameters-152">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>settings</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>New governance settings</td>
</tr>
</tbody>
</table>
<h3 id="_validategovernancesettings">_validateGovernanceSettings</h3>
<pre><code class="solidity language-solidity">function _validateGovernanceSettings(struct IGovernanceSettings.NewGovernanceSettings settings) internal pure</code></pre>
<p>Validates governance settings</p>
<h4 id="parameters-153">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>settings</td>
<td>struct IGovernanceSettings.NewGovernanceSettings</td>
<td>New governance settings</td>
</tr>
</tbody>
</table>
<h2 id="governor">Governor</h2>
<p>This contract extends the functionality of the pool contract. If the pool has been granted DAO status, Governance tokens can be used as votes during the voting process for proposals created for the pool. With this architecture, the pool can invoke methods on behalf of itself provided by this module to execute transactions prescribed by proposals.</p>
<p><em>This module provides additional methods for creating proposals, participating and observing the voting process, as well as safely and securely counting votes and executing decisions that have undergone voting.</em></p>
<h3 id="denom-4">DENOM</h3>
<pre><code class="solidity language-solidity">uint256 DENOM</code></pre>
<p>Denominator for shares (such as thresholds)</p>
<p><em>The constant Service.sol:DENOM is used to work with percentage values of QuorumThreshold and DecisionThreshold thresholds, as well as for calculating the ProtocolTokenFee. In this version, it is equal to 1,000,000, for clarity stored as 100 * 10 ^ 4.
    10^4 corresponds to one percent, and 100 * 10^4 corresponds to one hundred percent.
    The value of 12.3456% will be written as 123,456, and 78.9% as 789,000.
    This notation allows specifying ratios with an accuracy of up to four decimal places in percentage notation (six decimal places in decimal notation).
    When working with the CompanyDAO frontend, the application scripts automatically convert the familiar percentage notation into the required format. When using the contracts independently, this feature of value notation should be taken into account.</em></p>
<h3 id="proposalstate">ProposalState</h3>
<pre><code class="solidity language-solidity">enum ProposalState {
  None,
  Active,
  Failed,
  Delayed,
  AwaitingExecution,
  Executed,
  Cancelled
}</code></pre>
<h3 id="proposalvotingdata">ProposalVotingData</h3>
<pre><code class="solidity language-solidity">struct ProposalVotingData {
  uint256 startBlock;
  uint256 endBlock;
  uint256 availableVotes;
  uint256 forVotes;
  uint256 againstVotes;
  enum Governor.ProposalState executionState;
}</code></pre>
<h3 id="proposal">Proposal</h3>
<pre><code class="solidity language-solidity">struct Proposal {
  struct IGovernor.ProposalCoreData core;
  struct Governor.ProposalVotingData vote;
  struct IGovernor.ProposalMetaData meta;
}</code></pre>
<h3 id="proposals">proposals</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; struct Governor.Proposal) proposals</code></pre>
<p><em>In this mapping, the local identifier (specific to the pool's scope) is used as the key. The proposal is also registered in the Registry contract, where it is assigned a global number.</em></p>
<h3 id="ballot">Ballot</h3>
<pre><code class="solidity language-solidity">enum Ballot {
  None,
  Against,
  For
}</code></pre>
<h3 id="ballots">ballots</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; mapping(uint256 =&gt; enum Governor.Ballot)) ballots</code></pre>
<p>Mapping with the voting history.</p>
<p><em>The account address is used as the first key, and the proposal number is used as the second key. The stored value for these keys is described by the Ballot type.</em></p>
<h3 id="lastproposalid">lastProposalId</h3>
<pre><code class="solidity language-solidity">uint256 lastProposalId</code></pre>
<p><em>Last proposal ID</em></p>
<h3 id="proposalcreated">ProposalCreated</h3>
<pre><code class="solidity language-solidity">event ProposalCreated(uint256 proposalId, struct IGovernor.ProposalCoreData core, struct IGovernor.ProposalMetaData meta)</code></pre>
<p><em>Event emitted on proposal creation</em></p>
<h4 id="parameters-154">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
<tr>
<td>core</td>
<td>struct IGovernor.ProposalCoreData</td>
<td>Proposal core data</td>
</tr>
<tr>
<td>meta</td>
<td>struct IGovernor.ProposalMetaData</td>
<td>Proposal meta data</td>
</tr>
</tbody>
</table>
<h3 id="votecast">VoteCast</h3>
<pre><code class="solidity language-solidity">event VoteCast(address voter, uint256 proposalId, uint256 votes, enum Governor.Ballot ballot)</code></pre>
<p><em>Event emitted on proposal vote cast</em></p>
<h4 id="parameters-155">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>voter</td>
<td>address</td>
<td>Voter address</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
<tr>
<td>votes</td>
<td>uint256</td>
<td>Amount of votes</td>
</tr>
<tr>
<td>ballot</td>
<td>enum Governor.Ballot</td>
<td>Ballot (against or for)</td>
</tr>
</tbody>
</table>
<h3 id="proposalexecuted">ProposalExecuted</h3>
<pre><code class="solidity language-solidity">event ProposalExecuted(uint256 proposalId)</code></pre>
<p><em>Event emitted on proposal execution</em></p>
<h4 id="parameters-156">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="proposalcancelled-1">ProposalCancelled</h3>
<pre><code class="solidity language-solidity">event ProposalCancelled(uint256 proposalId)</code></pre>
<p><em>Event emitted on proposal cancellation</em></p>
<h4 id="parameters-157">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="proposalstate-1">proposalState</h3>
<pre><code class="solidity language-solidity">function proposalState(uint256 proposalId) public view returns (enum Governor.ProposalState)</code></pre>
<p>This method returns the state of the specified proposal.</p>
<p><em>Among the Governance Settings, there is a parameter called votingDuration, which contains the number of blocks for the duration of the vote, and a parameter called votingStartDelay, which contains the number of blocks for the delay of the vote's start relative to the block of the proposal's creation.
    The start and end blocks of the vote are placed in the Pool:proposals[proposalId] entry as vote.startBlock and vote.endBlock.
        vote.startBlock = block.number + votingStartDelay
        vote.endBlock = block.number + votingStartDelay + votingDuration
    The proposal status can be obtained from the Pool:proposalState(proposalId) method. It is formed by comparing the current block with the end block, as well as from proposals[proposalId].vote.executionState, which can store irreversible state flags "Canceled" or "Executed". This value is a numerical code for one of the proposal states, with all possible state types listed in Governor.sol:ProposalState.
    Before the endBlock occurs, the proposal has an Active status, but the ability to vote (using the castVote method in the Pool contract) only appears from the startBlock. This status means that the QuorumThreshold and/or DecisionThreshold have not yet been reached, and there is still a sufficient number of unused votes, the application of which can lead to either of the two results.
    When the endBlock occurs, the proposal is no longer Active. New votes are not accepted, and the state changes to:
    - Failed if the QuorumThreshold and/or DecisionThreshold were not met by the voters
    - Delayed if both thresholds were met.
    The Failed state is irreversible and means that the decision "for" was not made, i.e., the transactions prescribed by the proposal cannot be executed.
    The Delayed state means that the necessary number of votes has been cast "for" the proposal, but the transactions prescribed by the proposal can be executed only after proposals[proposalId].core.executionDelay blocks have passed.
    The AwaitingExecution state means that the necessary number of votes has been cast "for" the proposal, the delay has ended, and the transactions prescribed by the proposal can be executed right now.
    The Canceled state means that the address assigned the ADMIN role in the Service contract used the cancelProposal method of the Service contract and canceled the execution of the proposal. This method could work only if the proposal had an Active, Delayed, or AwaitingExecution state at the time of cancellation. This state is irreversible; the proposal permanently loses the ability to accept votes, and its transactions will not be executed.
    The Executed state means that the address assigned the SERVICE_MANAGER role in the Service contract, or the address assigned the Executor role in the Pool contract, or any address if no address was assigned the Executor role in the pool, used the executeProposal method in the Pool contract. This state means that all transactions prescribed by the proposal have been successfully executed.</em></p>
<h4 id="parameters-158">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Идентификатор Proposal.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-73">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>enum Governor.ProposalState</td>
<td>The state code using the ProposalState type.</td>
</tr>
</tbody>
</table>
<h3 id="getballot">getBallot</h3>
<pre><code class="solidity language-solidity">function getBallot(address account, uint256 proposalId) public view returns (enum Governor.Ballot ballot, uint256 votes)</code></pre>
<p><em>This method is used to work with the voting history and returns the vote code according to the Ballot type made by the specified account in the specified proposal. Additionally, using the pastVotes snapshots, it provides information about the number of votes this account had during the specified voting.</em></p>
<h4 id="parameters-159">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>Account address.</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal identifier.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-74">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ballot</td>
<td>enum Governor.Ballot</td>
<td>Vote type.</td>
</tr>
<tr>
<td>votes</td>
<td>uint256</td>
<td>Number of votes cast.</td>
</tr>
</tbody>
</table>
<h3 id="_propose">_propose</h3>
<pre><code class="solidity language-solidity">function _propose(struct IGovernor.ProposalCoreData core, struct IGovernor.ProposalMetaData meta, uint256 votingDuration, uint256 votingStartDelay) internal returns (uint256 proposalId)</code></pre>
<p><em>Creating a proposal and assigning it a unique identifier to store in the list of proposals in the Governor contract.</em></p>
<h4 id="parameters-160">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>core</td>
<td>struct IGovernor.ProposalCoreData</td>
<td>Proposal core data</td>
</tr>
<tr>
<td>meta</td>
<td>struct IGovernor.ProposalMetaData</td>
<td>Proposal meta data</td>
</tr>
<tr>
<td>votingDuration</td>
<td>uint256</td>
<td>Voting duration in blocks</td>
</tr>
<tr>
<td>votingStartDelay</td>
<td>uint256</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="_castvote">_castVote</h3>
<pre><code class="solidity language-solidity">function _castVote(uint256 proposalId, bool support) internal</code></pre>
<p>Implementation of the voting method for the pool contract.</p>
<p><em>This method includes a check that the proposal is still in the "Active" state and eligible for the user to cast their vote. Additionally, each invocation of this method results in an additional check for the conditions to prematurely end the voting.</em></p>
<h4 id="parameters-161">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID.</td>
</tr>
<tr>
<td>support</td>
<td>bool</td>
<td>"True" for a vote "in favor/for," "False" otherwise.</td>
</tr>
</tbody>
</table>
<h3 id="_executeproposal">_executeProposal</h3>
<pre><code class="solidity language-solidity">function _executeProposal(uint256 proposalId, contract IService service) internal</code></pre>
<p><em>Performance of the proposal with checking its status. Only the Awaiting Execution of the proposals can be executed.</em></p>
<h4 id="parameters-162">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
<tr>
<td>service</td>
<td>contract IService</td>
<td>Service address</td>
</tr>
</tbody>
</table>
<h3 id="_cancelproposal">_cancelProposal</h3>
<pre><code class="solidity language-solidity">function _cancelProposal(uint256 proposalId) internal</code></pre>
<p><em>The substitution of proposals, both active and those that have a positive voting result, but have not yet been executed.</em></p>
<h4 id="parameters-163">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="_checkproposalvotingearlyend">_checkProposalVotingEarlyEnd</h3>
<pre><code class="solidity language-solidity">function _checkProposalVotingEarlyEnd(uint256 proposalId) internal</code></pre>
<p>The method checks whether it is possible to end the voting early with the result fixed. If a quorum was reached and so many votes were cast in favor that even if all other available votes were cast against, or if so many votes were cast against that it could not affect the result of the vote, this function will change set the end block of the proposal to the current block</p>
<p><em>During the voting process, a situation may arise when such a number of votes have been cast "for" or "against" a proposal that no matter how the remaining votes are distributed, the outcome of the proposal will not change.
    This can occur in the following situations:
    - The sum of "for" votes and unused votes does not exceed the DecisionThreshold of the total number of votes allowed in the voting process (occurs when there are so many "against" votes that even using the remaining votes in favor of the proposal will not allow overcoming the DecisionThreshold).
    - The number of "for" votes is no less than the DecisionThreshold of the total number of votes allowed in the voting process (occurs when there are so many "for" votes that even if all the remaining unused votes are cast "against", the proposal will still be considered accepted).
    Both of these conditions trigger ONLY when the QuorumThreshold is reached simultaneously.
    In such cases, further voting and waiting become pointless and meaningless. No subsequent vote can influence the outcome of the voting to change.
    Therefore, an additional check for triggering the conditions described above has been added to the Pool:castVote method. If the vote can be safely terminated early, the proposals[proposalId].vote.endBlock is changed to the current one during the method's execution.
    This means that the state of the proposal ceases to be Active and should change to Failed or Delayed.</em></p>
<h4 id="parameters-164">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="sharereached">shareReached</h3>
<pre><code class="solidity language-solidity">function shareReached(uint256 amount, uint256 total, uint256 share) internal pure returns (bool)</code></pre>
<p><em>Checks if <code>amount</code> divided by <code>total</code> exceeds <code>share</code></em></p>
<h4 id="parameters-165">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>uint256</td>
<td>Amount numerator</td>
</tr>
<tr>
<td>total</td>
<td>uint256</td>
<td>Amount denominator</td>
</tr>
<tr>
<td>share</td>
<td>uint256</td>
<td>Share numerator</td>
</tr>
</tbody>
</table>
<h3 id="shareovercome">shareOvercome</h3>
<pre><code class="solidity language-solidity">function shareOvercome(uint256 amount, uint256 total, uint256 share) internal pure returns (bool)</code></pre>
<p><em>Checks if <code>amount</code> divided by <code>total</code> overcomes <code>share</code></em></p>
<h4 id="parameters-166">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>uint256</td>
<td>Amount numerator</td>
</tr>
<tr>
<td>total</td>
<td>uint256</td>
<td>Amount denominator</td>
</tr>
<tr>
<td>share</td>
<td>uint256</td>
<td>Share numerator</td>
</tr>
</tbody>
</table>
<h3 id="_afterproposalcreated-1">_afterProposalCreated</h3>
<pre><code class="solidity language-solidity">function _afterProposalCreated(uint256 proposalId) internal virtual</code></pre>
<p><em>Hook called after a proposal is created</em></p>
<h4 id="parameters-167">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="_getblocktotalvotes-1">_getBlockTotalVotes</h3>
<pre><code class="solidity language-solidity">function _getBlockTotalVotes(uint256 blocknumber) internal view virtual returns (uint256)</code></pre>
<p><em>Function that returns the total amount of votes in the pool in block</em></p>
<h4 id="parameters-168">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>blocknumber</td>
<td>uint256</td>
<td>block number</td>
</tr>
</tbody>
</table>
<h4 id="return-values-75">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>Total amount of votes</td>
</tr>
</tbody>
</table>
<h3 id="_getpastvotes-1">_getPastVotes</h3>
<pre><code class="solidity language-solidity">function _getPastVotes(address account, uint256 blockNumber) internal view virtual returns (uint256)</code></pre>
<p><em>Function that returns the amount of votes for a client adrress at any given block</em></p>
<h4 id="parameters-169">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>Account's address</td>
</tr>
<tr>
<td>blockNumber</td>
<td>uint256</td>
<td>Block number</td>
</tr>
</tbody>
</table>
<h4 id="return-values-76">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>Account's votes at given block</td>
</tr>
</tbody>
</table>
<h3 id="_setlastproposalidforaddress-1">_setLastProposalIdForAddress</h3>
<pre><code class="solidity language-solidity">function _setLastProposalIdForAddress(address proposer, uint256 proposalId) internal virtual</code></pre>
<p><em>Function that set last ProposalId for a client address</em></p>
<h4 id="parameters-170">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposer</td>
<td>address</td>
<td>Proposer's address</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal id</td>
</tr>
</tbody>
</table>
<h2 id="governorproposals">GovernorProposals</h2>
<p>Contract for tracking and typing the created proposals.</p>
<p><em>The final implementation of the voting logic is placed in this module, which inherits from the Governor contract and is inherited by pool contracts.</em></p>
<h3 id="service-6">service</h3>
<pre><code class="solidity language-solidity">contract IService service</code></pre>
<p><em>The address of the Service contract.</em></p>
<h3 id="lastproposalidbytype">lastProposalIdByType</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; uint256) lastProposalIdByType</code></pre>
<p><em>last Proposal Id By Type for state checking</em></p>
<h3 id="proposaltype">ProposalType</h3>
<pre><code class="solidity language-solidity">enum ProposalType {
  Transfer,
  TGE,
  GovernanceSettings
}</code></pre>
<h3 id="__gap-1">__gap</h3>
<pre><code class="solidity language-solidity">uint256[49] __gap</code></pre>
<p>Storage gap (for future upgrades)</p>
<h2 id="icustomproposal">ICustomProposal</h2>
<h2 id="iinvoice">IInvoice</h2>
<p>These structures are used to describe an instance of an invoice.</p>
<p><em>The storage of invoices is managed in Invoice.sol in the <code>invoices</code> variable.</em></p>
<h3 id="invoicecore">InvoiceCore</h3>
<pre><code class="solidity language-solidity">struct InvoiceCore {
  uint256 amount;
  address unitOfAccount;
  uint256 expirationBlock;
  string description;
  address[] whitelist;
}</code></pre>
<h3 id="invoiceinfo">InvoiceInfo</h3>
<pre><code class="solidity language-solidity">struct InvoiceInfo {
  struct IInvoice.InvoiceCore core;
  uint256 invoiceId;
  address createdBy;
  bool isPaid;
  bool isCanceled;
}</code></pre>
<h3 id="invoicestate-1">InvoiceState</h3>
<pre><code class="solidity language-solidity">enum InvoiceState {
  None,
  Active,
  Paid,
  Expired,
  Canceled
}</code></pre>
<h3 id="createinvoice-1">createInvoice</h3>
<pre><code class="solidity language-solidity">function createInvoice(address pool, struct IInvoice.InvoiceCore core) external</code></pre>
<h3 id="payinvoice-1">payInvoice</h3>
<pre><code class="solidity language-solidity">function payInvoice(address pool, uint256 invoiceId) external payable</code></pre>
<h3 id="cancelinvoice-1">cancelInvoice</h3>
<pre><code class="solidity language-solidity">function cancelInvoice(address pool, uint256 invoiceId) external</code></pre>
<h3 id="setinvoicecanceled-1">setInvoiceCanceled</h3>
<pre><code class="solidity language-solidity">function setInvoiceCanceled(address pool, uint256 invoiceId) external</code></pre>
<h2 id="ipausable">IPausable</h2>
<h3 id="paused-1">paused</h3>
<pre><code class="solidity language-solidity">function paused() external view returns (bool)</code></pre>
<h2 id="ipool">IPool</h2>
<h3 id="initialize-11">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(struct ICompaniesRegistry.CompanyInfo companyInfo_) external</code></pre>
<h3 id="setnewownerwithsettings-1">setNewOwnerWithSettings</h3>
<pre><code class="solidity language-solidity">function setNewOwnerWithSettings(address owner_, string trademark_, struct IGovernanceSettings.NewGovernanceSettings governanceSettings_) external</code></pre>
<h3 id="propose-1">propose</h3>
<pre><code class="solidity language-solidity">function propose(address proposer, uint256 proposalType, struct IGovernor.ProposalCoreData core, struct IGovernor.ProposalMetaData meta) external returns (uint256 proposalId)</code></pre>
<h3 id="settoken-1">setToken</h3>
<pre><code class="solidity language-solidity">function setToken(address token_, enum IToken.TokenType tokenType_) external</code></pre>
<h3 id="setproposalidtotge-1">setProposalIdToTGE</h3>
<pre><code class="solidity language-solidity">function setProposalIdToTGE(address tge) external</code></pre>
<h3 id="cancelproposal-2">cancelProposal</h3>
<pre><code class="solidity language-solidity">function cancelProposal(uint256 proposalId) external</code></pre>
<h3 id="setsettings-1">setSettings</h3>
<pre><code class="solidity language-solidity">function setSettings(struct IGovernanceSettings.NewGovernanceSettings governanceSettings_, address[] secretary, address[] executor) external</code></pre>
<h3 id="owner-1">owner</h3>
<pre><code class="solidity language-solidity">function owner() external view returns (address)</code></pre>
<h3 id="isdao-1">isDAO</h3>
<pre><code class="solidity language-solidity">function isDAO() external view returns (bool)</code></pre>
<h3 id="trademark-1">trademark</h3>
<pre><code class="solidity language-solidity">function trademark() external view returns (string)</code></pre>
<h3 id="getgovernancetoken-1">getGovernanceToken</h3>
<pre><code class="solidity language-solidity">function getGovernanceToken() external view returns (contract IToken)</code></pre>
<h3 id="tokenexists-1">tokenExists</h3>
<pre><code class="solidity language-solidity">function tokenExists(contract IToken token_) external view returns (bool)</code></pre>
<h3 id="tokentypebyaddress-1">tokenTypeByAddress</h3>
<pre><code class="solidity language-solidity">function tokenTypeByAddress(address token_) external view returns (enum IToken.TokenType)</code></pre>
<h3 id="isvalidproposer-1">isValidProposer</h3>
<pre><code class="solidity language-solidity">function isValidProposer(address account) external view returns (bool)</code></pre>
<h3 id="ispoolsecretary-1">isPoolSecretary</h3>
<pre><code class="solidity language-solidity">function isPoolSecretary(address account) external view returns (bool)</code></pre>
<h3 id="islastproposalidbytypeactive-1">isLastProposalIdByTypeActive</h3>
<pre><code class="solidity language-solidity">function isLastProposalIdByTypeActive(uint256 type_) external view returns (bool)</code></pre>
<h3 id="validategovernancesettings-1">validateGovernanceSettings</h3>
<pre><code class="solidity language-solidity">function validateGovernanceSettings(struct IGovernanceSettings.NewGovernanceSettings settings) external pure</code></pre>
<h3 id="getpoolsecretary-1">getPoolSecretary</h3>
<pre><code class="solidity language-solidity">function getPoolSecretary() external view returns (address[])</code></pre>
<h3 id="getpoolexecutor-1">getPoolExecutor</h3>
<pre><code class="solidity language-solidity">function getPoolExecutor() external view returns (address[])</code></pre>
<h3 id="setcompanyinfo-1">setCompanyInfo</h3>
<pre><code class="solidity language-solidity">function setCompanyInfo(uint256 _jurisdiction, uint256 _entityType, string _ein, string _dateOfIncorporation, string _OAuri) external</code></pre>
<h3 id="castvote-1">castVote</h3>
<pre><code class="solidity language-solidity">function castVote(uint256 proposalId, bool support) external</code></pre>
<h3 id="executeproposal-1">executeProposal</h3>
<pre><code class="solidity language-solidity">function executeProposal(uint256 proposalId) external</code></pre>
<h2 id="iservice">IService</h2>
<h3 id="admin_role-1">ADMIN_ROLE</h3>
<pre><code class="solidity language-solidity">function ADMIN_ROLE() external view returns (bytes32)</code></pre>
<h3 id="whitelisted_user_role-1">WHITELISTED_USER_ROLE</h3>
<pre><code class="solidity language-solidity">function WHITELISTED_USER_ROLE() external view returns (bytes32)</code></pre>
<h3 id="service_manager_role-1">SERVICE_MANAGER_ROLE</h3>
<pre><code class="solidity language-solidity">function SERVICE_MANAGER_ROLE() external view returns (bytes32)</code></pre>
<h3 id="executor_role-1">EXECUTOR_ROLE</h3>
<pre><code class="solidity language-solidity">function EXECUTOR_ROLE() external view returns (bytes32)</code></pre>
<h3 id="createpool-1">createPool</h3>
<pre><code class="solidity language-solidity">function createPool(struct ICompaniesRegistry.CompanyInfo companyInfo) external</code></pre>
<h3 id="addproposal-1">addProposal</h3>
<pre><code class="solidity language-solidity">function addProposal(uint256 proposalId) external</code></pre>
<h3 id="addevent-1">addEvent</h3>
<pre><code class="solidity language-solidity">function addEvent(enum IRecordsRegistry.EventType eventType, uint256 proposalId, string metaHash) external</code></pre>
<h3 id="setprotocolcollectedfee-1">setProtocolCollectedFee</h3>
<pre><code class="solidity language-solidity">function setProtocolCollectedFee(address _token, uint256 _protocolTokenFee) external</code></pre>
<h3 id="registry-4">registry</h3>
<pre><code class="solidity language-solidity">function registry() external view returns (contract IRegistry)</code></pre>
<h3 id="vesting-3">vesting</h3>
<pre><code class="solidity language-solidity">function vesting() external view returns (contract IVesting)</code></pre>
<h3 id="tokenfactory-2">tokenFactory</h3>
<pre><code class="solidity language-solidity">function tokenFactory() external view returns (contract ITokenFactory)</code></pre>
<h3 id="tgefactory-2">tgeFactory</h3>
<pre><code class="solidity language-solidity">function tgeFactory() external view returns (contract ITGEFactory)</code></pre>
<h3 id="invoice-2">invoice</h3>
<pre><code class="solidity language-solidity">function invoice() external view returns (contract IInvoice)</code></pre>
<h3 id="protocoltreasury-1">protocolTreasury</h3>
<pre><code class="solidity language-solidity">function protocolTreasury() external view returns (address)</code></pre>
<h3 id="protocoltokenfee-1">protocolTokenFee</h3>
<pre><code class="solidity language-solidity">function protocolTokenFee() external view returns (uint256)</code></pre>
<h3 id="getminsoftcap-1">getMinSoftCap</h3>
<pre><code class="solidity language-solidity">function getMinSoftCap() external view returns (uint256)</code></pre>
<h3 id="getprotocoltokenfee-2">getProtocolTokenFee</h3>
<pre><code class="solidity language-solidity">function getProtocolTokenFee(uint256 amount) external view returns (uint256)</code></pre>
<h3 id="getprotocolcollectedfee-1">getProtocolCollectedFee</h3>
<pre><code class="solidity language-solidity">function getProtocolCollectedFee(address token_) external view returns (uint256)</code></pre>
<h3 id="poolbeacon-1">poolBeacon</h3>
<pre><code class="solidity language-solidity">function poolBeacon() external view returns (address)</code></pre>
<h3 id="tgebeacon-1">tgeBeacon</h3>
<pre><code class="solidity language-solidity">function tgeBeacon() external view returns (address)</code></pre>
<h3 id="tokenbeacon-1">tokenBeacon</h3>
<pre><code class="solidity language-solidity">function tokenBeacon() external view returns (address)</code></pre>
<h3 id="tokenerc1155beacon-1">tokenERC1155Beacon</h3>
<pre><code class="solidity language-solidity">function tokenERC1155Beacon() external view returns (address)</code></pre>
<h3 id="customproposal-2">customProposal</h3>
<pre><code class="solidity language-solidity">function customProposal() external view returns (contract ICustomProposal)</code></pre>
<h3 id="validatetgeinfo-1">validateTGEInfo</h3>
<pre><code class="solidity language-solidity">function validateTGEInfo(struct ITGE.TGEInfo info, uint256 cap, uint256 totalSupply, enum IToken.TokenType tokenType) external view</code></pre>
<h3 id="getpooladdress-1">getPoolAddress</h3>
<pre><code class="solidity language-solidity">function getPoolAddress(struct ICompaniesRegistry.CompanyInfo info) external view returns (address)</code></pre>
<h3 id="paused-2">paused</h3>
<pre><code class="solidity language-solidity">function paused() external view returns (bool)</code></pre>
<h3 id="addinvoiceevent-1">addInvoiceEvent</h3>
<pre><code class="solidity language-solidity">function addInvoiceEvent(address pool, uint256 invoiceId) external returns (uint256)</code></pre>
<h3 id="purchasepool-1">purchasePool</h3>
<pre><code class="solidity language-solidity">function purchasePool(uint256 jurisdiction, uint256 entityType, string trademark, struct IGovernanceSettings.NewGovernanceSettings governanceSettings) external payable</code></pre>
<h3 id="transferpurchasedpoolbyservice-1">transferPurchasedPoolByService</h3>
<pre><code class="solidity language-solidity">function transferPurchasedPoolByService(address newowner, uint256 jurisdiction, uint256 entityType, string trademark, struct IGovernanceSettings.NewGovernanceSettings governanceSettings) external</code></pre>
<h2 id="itge">ITGE</h2>
<h3 id="tgeinfo">TGEInfo</h3>
<pre><code class="solidity language-solidity">struct TGEInfo {
  uint256 price;
  uint256 hardcap;
  uint256 softcap;
  uint256 minPurchase;
  uint256 maxPurchase;
  uint256 duration;
  struct IVesting.VestingParams vestingParams;
  address[] userWhitelist;
  address unitOfAccount;
  uint256 lockupDuration;
  uint256 lockupTVL;
}</code></pre>
<h3 id="initialize-12">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(address _service, address _token, uint256 _tokenId, string _uri, struct ITGE.TGEInfo _info, uint256 _protocolFee) external</code></pre>
<h3 id="state-1">State</h3>
<pre><code class="solidity language-solidity">enum State {
  Active,
  Failed,
  Successful
}</code></pre>
<h3 id="token-2">token</h3>
<pre><code class="solidity language-solidity">function token() external view returns (address)</code></pre>
<h3 id="tokenid-1">tokenId</h3>
<pre><code class="solidity language-solidity">function tokenId() external view returns (uint256)</code></pre>
<h3 id="state-2">state</h3>
<pre><code class="solidity language-solidity">function state() external view returns (enum ITGE.State)</code></pre>
<h3 id="getinfo-1">getInfo</h3>
<pre><code class="solidity language-solidity">function getInfo() external view returns (struct ITGE.TGEInfo)</code></pre>
<h3 id="transferunlocked-1">transferUnlocked</h3>
<pre><code class="solidity language-solidity">function transferUnlocked() external view returns (bool)</code></pre>
<h3 id="purchaseof-1">purchaseOf</h3>
<pre><code class="solidity language-solidity">function purchaseOf(address user) external view returns (uint256)</code></pre>
<h3 id="redeemablebalanceof-1">redeemableBalanceOf</h3>
<pre><code class="solidity language-solidity">function redeemableBalanceOf(address user) external view returns (uint256)</code></pre>
<h3 id="lockedbalanceof-1">lockedBalanceOf</h3>
<pre><code class="solidity language-solidity">function lockedBalanceOf(address account) external view returns (uint256)</code></pre>
<h3 id="getend-1">getEnd</h3>
<pre><code class="solidity language-solidity">function getEnd() external view returns (uint256)</code></pre>
<h3 id="totalpurchased-1">totalPurchased</h3>
<pre><code class="solidity language-solidity">function totalPurchased() external view returns (uint256)</code></pre>
<h3 id="iserc1155tge-1">isERC1155TGE</h3>
<pre><code class="solidity language-solidity">function isERC1155TGE() external view returns (bool)</code></pre>
<h3 id="purchase-1">purchase</h3>
<pre><code class="solidity language-solidity">function purchase(uint256 amount) external payable</code></pre>
<h3 id="transferfunds-1">transferFunds</h3>
<pre><code class="solidity language-solidity">function transferFunds() external</code></pre>
<h2 id="itgefactory">ITGEFactory</h2>
<h3 id="createsecondarytge-1">createSecondaryTGE</h3>
<pre><code class="solidity language-solidity">function createSecondaryTGE(address token, struct ITGE.TGEInfo tgeInfo, struct IToken.TokenInfo tokenInfo, string metadataURI) external</code></pre>
<h3 id="createsecondarytgeerc1155-1">createSecondaryTGEERC1155</h3>
<pre><code class="solidity language-solidity">function createSecondaryTGEERC1155(address token, uint256 tokenId, string uri, struct ITGE.TGEInfo tgeInfo, struct IToken.TokenInfo tokenInfo, string metadataURI) external</code></pre>
<h3 id="createprimarytge-1">createPrimaryTGE</h3>
<pre><code class="solidity language-solidity">function createPrimaryTGE(address poolAddress, struct IToken.TokenInfo tokenInfo, struct ITGE.TGEInfo tgeInfo, string metadataURI, struct IGovernanceSettings.NewGovernanceSettings governanceSettings_, address[] secretary, address[] executor) external</code></pre>
<h2 id="itoken">IToken</h2>
<h3 id="tokeninfo">TokenInfo</h3>
<pre><code class="solidity language-solidity">struct TokenInfo {
  enum IToken.TokenType tokenType;
  string name;
  string symbol;
  string description;
  uint256 cap;
  uint8 decimals;
}</code></pre>
<h3 id="tokentype-2">TokenType</h3>
<pre><code class="solidity language-solidity">enum TokenType {
  None,
  Governance,
  Preference
}</code></pre>
<h3 id="initialize-13">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(contract IService service_, address pool_, struct IToken.TokenInfo info, address primaryTGE_) external</code></pre>
<h3 id="mint-2">mint</h3>
<pre><code class="solidity language-solidity">function mint(address to, uint256 amount) external</code></pre>
<h3 id="burn-2">burn</h3>
<pre><code class="solidity language-solidity">function burn(address from, uint256 amount) external</code></pre>
<h3 id="cap-2">cap</h3>
<pre><code class="solidity language-solidity">function cap() external view returns (uint256)</code></pre>
<h3 id="unlockedbalanceof-3">unlockedBalanceOf</h3>
<pre><code class="solidity language-solidity">function unlockedBalanceOf(address account) external view returns (uint256)</code></pre>
<h3 id="pool-3">pool</h3>
<pre><code class="solidity language-solidity">function pool() external view returns (address)</code></pre>
<h3 id="service-7">service</h3>
<pre><code class="solidity language-solidity">function service() external view returns (contract IService)</code></pre>
<h3 id="decimals-2">decimals</h3>
<pre><code class="solidity language-solidity">function decimals() external view returns (uint8)</code></pre>
<h3 id="symbol-2">symbol</h3>
<pre><code class="solidity language-solidity">function symbol() external view returns (string)</code></pre>
<h3 id="tokentype-3">tokenType</h3>
<pre><code class="solidity language-solidity">function tokenType() external view returns (enum IToken.TokenType)</code></pre>
<h3 id="lasttge-2">lastTGE</h3>
<pre><code class="solidity language-solidity">function lastTGE() external view returns (address)</code></pre>
<h3 id="gettgelist-2">getTGEList</h3>
<pre><code class="solidity language-solidity">function getTGEList() external view returns (address[])</code></pre>
<h3 id="isprimarytgesuccessful-2">isPrimaryTGESuccessful</h3>
<pre><code class="solidity language-solidity">function isPrimaryTGESuccessful() external view returns (bool)</code></pre>
<h3 id="addtge-2">addTGE</h3>
<pre><code class="solidity language-solidity">function addTGE(address tge) external</code></pre>
<h3 id="settgevestedtokens-2">setTGEVestedTokens</h3>
<pre><code class="solidity language-solidity">function setTGEVestedTokens(uint256 amount) external</code></pre>
<h3 id="setprotocolfeereserved-2">setProtocolFeeReserved</h3>
<pre><code class="solidity language-solidity">function setProtocolFeeReserved(uint256 amount) external</code></pre>
<h3 id="gettotaltgevestedtokens-2">getTotalTGEVestedTokens</h3>
<pre><code class="solidity language-solidity">function getTotalTGEVestedTokens() external view returns (uint256)</code></pre>
<h3 id="gettotalprotocolfeereserved-2">getTotalProtocolFeeReserved</h3>
<pre><code class="solidity language-solidity">function getTotalProtocolFeeReserved() external view returns (uint256)</code></pre>
<h3 id="totalsupplywithreserves-2">totalSupplyWithReserves</h3>
<pre><code class="solidity language-solidity">function totalSupplyWithReserves() external view returns (uint256)</code></pre>
<h3 id="transferfrom-1">transferFrom</h3>
<pre><code class="solidity language-solidity">function transferFrom(address from, address to, uint256 amount) external returns (bool)</code></pre>
<p>_Moves <code>amount</code> tokens from <code>from</code> to <code>to</code> using the<br />
allowance mechanism. <code>amount</code> is then deducted from the caller's<br />
allowance.</p>
<p>Returns a boolean value indicating whether the operation succeeded.</p>
<p>Emits a {Transfer} event._</p>
<h3 id="transfer-2">transfer</h3>
<pre><code class="solidity language-solidity">function transfer(address to, uint256 amount) external returns (bool)</code></pre>
<p>_Moves <code>amount</code> tokens from the caller's account to <code>to</code>.</p>
<p>Returns a boolean value indicating whether the operation succeeded.</p>
<p>Emits a {Transfer} event._</p>
<h2 id="itokenerc1155">ITokenERC1155</h2>
<h3 id="initialize-14">initialize</h3>
<pre><code class="solidity language-solidity">function initialize(contract IService service_, address pool_, struct IToken.TokenInfo info, address primaryTGE_) external</code></pre>
<h3 id="mint-3">mint</h3>
<pre><code class="solidity language-solidity">function mint(address to, uint256 tokenId, uint256 amount) external</code></pre>
<h3 id="burn-3">burn</h3>
<pre><code class="solidity language-solidity">function burn(address from, uint256 tokenId, uint256 amount) external</code></pre>
<h3 id="cap-3">cap</h3>
<pre><code class="solidity language-solidity">function cap(uint256 tokenId) external view returns (uint256)</code></pre>
<h3 id="unlockedbalanceof-4">unlockedBalanceOf</h3>
<pre><code class="solidity language-solidity">function unlockedBalanceOf(address account, uint256 tokenId) external view returns (uint256)</code></pre>
<h3 id="pool-4">pool</h3>
<pre><code class="solidity language-solidity">function pool() external view returns (address)</code></pre>
<h3 id="service-8">service</h3>
<pre><code class="solidity language-solidity">function service() external view returns (contract IService)</code></pre>
<h3 id="decimals-3">decimals</h3>
<pre><code class="solidity language-solidity">function decimals() external view returns (uint8)</code></pre>
<h3 id="symbol-3">symbol</h3>
<pre><code class="solidity language-solidity">function symbol() external view returns (string)</code></pre>
<h3 id="tokentype-4">tokenType</h3>
<pre><code class="solidity language-solidity">function tokenType() external view returns (enum IToken.TokenType)</code></pre>
<h3 id="lasttge-3">lastTGE</h3>
<pre><code class="solidity language-solidity">function lastTGE(uint256 tokenId) external view returns (address)</code></pre>
<h3 id="gettgelist-3">getTGEList</h3>
<pre><code class="solidity language-solidity">function getTGEList(uint256 tokenId) external view returns (address[])</code></pre>
<h3 id="isprimarytgesuccessful-3">isPrimaryTGESuccessful</h3>
<pre><code class="solidity language-solidity">function isPrimaryTGESuccessful(uint256 tokenId) external view returns (bool)</code></pre>
<h3 id="addtge-3">addTGE</h3>
<pre><code class="solidity language-solidity">function addTGE(address tge, uint256 tokenId) external</code></pre>
<h3 id="settgevestedtokens-3">setTGEVestedTokens</h3>
<pre><code class="solidity language-solidity">function setTGEVestedTokens(uint256 amount, uint256 tokenId) external</code></pre>
<h3 id="setprotocolfeereserved-3">setProtocolFeeReserved</h3>
<pre><code class="solidity language-solidity">function setProtocolFeeReserved(uint256 amount, uint256 tokenId) external</code></pre>
<h3 id="gettotaltgevestedtokens-3">getTotalTGEVestedTokens</h3>
<pre><code class="solidity language-solidity">function getTotalTGEVestedTokens(uint256 tokenId) external view returns (uint256)</code></pre>
<h3 id="gettotalprotocolfeereserved-3">getTotalProtocolFeeReserved</h3>
<pre><code class="solidity language-solidity">function getTotalProtocolFeeReserved(uint256 tokenId) external view returns (uint256)</code></pre>
<h3 id="totalsupplywithreserves-3">totalSupplyWithReserves</h3>
<pre><code class="solidity language-solidity">function totalSupplyWithReserves(uint256 tokenId) external view returns (uint256)</code></pre>
<h3 id="seturi-1">setURI</h3>
<pre><code class="solidity language-solidity">function setURI(uint256 tokenId, string tokenURI) external</code></pre>
<h3 id="settokenidcap-1">setTokenIdCap</h3>
<pre><code class="solidity language-solidity">function setTokenIdCap(uint256 _tokenId, uint256 _cap) external</code></pre>
<h3 id="transfer-3">transfer</h3>
<pre><code class="solidity language-solidity">function transfer(address from, address to, uint256 tokenId, uint256 amount) external</code></pre>
<h2 id="itokenfactory">ITokenFactory</h2>
<h3 id="createtoken-1">createToken</h3>
<pre><code class="solidity language-solidity">function createToken(address pool, struct IToken.TokenInfo info, address primaryTGE) external returns (address token)</code></pre>
<h3 id="createtokenerc1155-1">createTokenERC1155</h3>
<pre><code class="solidity language-solidity">function createTokenERC1155(address pool, struct IToken.TokenInfo info, address primaryTGE) external returns (address token)</code></pre>
<h2 id="ivesting">IVesting</h2>
<h3 id="vestingparams-1">VestingParams</h3>
<pre><code class="solidity language-solidity">struct VestingParams {
  uint256 vestedShare;
  uint256 cliff;
  uint256 cliffShare;
  uint256 spans;
  uint256 spanDuration;
  uint256 spanShare;
  uint256 claimTVL;
  address[] resolvers;
}</code></pre>
<h3 id="vest-1">vest</h3>
<pre><code class="solidity language-solidity">function vest(address to, uint256 amount) external</code></pre>
<h3 id="cancel-1">cancel</h3>
<pre><code class="solidity language-solidity">function cancel(address tge, address account) external</code></pre>
<h3 id="validateparams-1">validateParams</h3>
<pre><code class="solidity language-solidity">function validateParams(struct IVesting.VestingParams params) external pure returns (bool)</code></pre>
<h3 id="vested-2">vested</h3>
<pre><code class="solidity language-solidity">function vested(address tge, address account) external view returns (uint256)</code></pre>
<h3 id="totalvested-4">totalVested</h3>
<pre><code class="solidity language-solidity">function totalVested(address tge) external view returns (uint256)</code></pre>
<h3 id="vestedbalanceof-2">vestedBalanceOf</h3>
<pre><code class="solidity language-solidity">function vestedBalanceOf(address tge, address account) external view returns (uint256)</code></pre>
<h2 id="igovernancesettings">IGovernanceSettings</h2>
<h3 id="newgovernancesettings">NewGovernanceSettings</h3>
<pre><code class="solidity language-solidity">struct NewGovernanceSettings {
  uint256 proposalThreshold;
  uint256 quorumThreshold;
  uint256 decisionThreshold;
  uint256 votingDuration;
  uint256 transferValueForDelay;
  uint256[4] executionDelays;
  uint256 votingStartDelay;
}</code></pre>
<h3 id="setgovernancesettings-1">setGovernanceSettings</h3>
<pre><code class="solidity language-solidity">function setGovernanceSettings(struct IGovernanceSettings.NewGovernanceSettings settings) external</code></pre>
<h2 id="igovernor">IGovernor</h2>
<h3 id="proposalcoredata">ProposalCoreData</h3>
<pre><code class="solidity language-solidity">struct ProposalCoreData {
  address[] targets;
  uint256[] values;
  bytes[] callDatas;
  uint256 quorumThreshold;
  uint256 decisionThreshold;
  uint256 executionDelay;
}</code></pre>
<h3 id="proposalmetadata">ProposalMetaData</h3>
<pre><code class="solidity language-solidity">struct ProposalMetaData {
  enum IRecordsRegistry.EventType proposalType;
  string description;
  string metaHash;
}</code></pre>
<h3 id="proposalstate-2">proposalState</h3>
<pre><code class="solidity language-solidity">function proposalState(uint256 proposalId) external view returns (uint256 state)</code></pre>
<h2 id="igovernorproposals">IGovernorProposals</h2>
<h3 id="service-9">service</h3>
<pre><code class="solidity language-solidity">function service() external view returns (contract IService)</code></pre>
<h2 id="icompaniesregistry">ICompaniesRegistry</h2>
<h3 id="companyinfo-1">CompanyInfo</h3>
<pre><code class="solidity language-solidity">struct CompanyInfo {
  uint256 jurisdiction;
  uint256 entityType;
  string ein;
  string dateOfIncorporation;
  uint256 fee;
}</code></pre>
<h3 id="lockcompany">lockCompany</h3>
<pre><code class="solidity language-solidity">function lockCompany(uint256 jurisdiction, uint256 entityType) external returns (struct ICompaniesRegistry.CompanyInfo)</code></pre>
<h3 id="createcompany">createCompany</h3>
<pre><code class="solidity language-solidity">function createCompany(struct ICompaniesRegistry.CompanyInfo info) external</code></pre>
<h2 id="irecordsregistry">IRecordsRegistry</h2>
<h3 id="contracttype">ContractType</h3>
<pre><code class="solidity language-solidity">enum ContractType {
  None,
  Pool,
  GovernanceToken,
  PreferenceToken,
  TGE
}</code></pre>
<h3 id="eventtype">EventType</h3>
<pre><code class="solidity language-solidity">enum EventType {
  None,
  Transfer,
  TGE,
  GovernanceSettings
}</code></pre>
<h3 id="contractinfo">ContractInfo</h3>
<pre><code class="solidity language-solidity">struct ContractInfo {
  address addr;
  enum IRecordsRegistry.ContractType contractType;
  string description;
}</code></pre>
<h3 id="proposalinfo">ProposalInfo</h3>
<pre><code class="solidity language-solidity">struct ProposalInfo {
  address pool;
  uint256 proposalId;
  string description;
}</code></pre>
<h3 id="event">Event</h3>
<pre><code class="solidity language-solidity">struct Event {
  enum IRecordsRegistry.EventType eventType;
  address pool;
  address eventContract;
  uint256 proposalId;
  string metaHash;
}</code></pre>
<h3 id="addcontractrecord">addContractRecord</h3>
<pre><code class="solidity language-solidity">function addContractRecord(address addr, enum IRecordsRegistry.ContractType contractType, string description) external returns (uint256 index)</code></pre>
<h3 id="addproposalrecord">addProposalRecord</h3>
<pre><code class="solidity language-solidity">function addProposalRecord(address pool, uint256 proposalId) external returns (uint256 index)</code></pre>
<h3 id="addeventrecord">addEventRecord</h3>
<pre><code class="solidity language-solidity">function addEventRecord(address pool, enum IRecordsRegistry.EventType eventType, address eventContract, uint256 proposalId, string metaHash) external returns (uint256 index)</code></pre>
<h3 id="typeof">typeOf</h3>
<pre><code class="solidity language-solidity">function typeOf(address addr) external view returns (enum IRecordsRegistry.ContractType)</code></pre>
<h2 id="iregistry">IRegistry</h2>
<h3 id="service-10">service</h3>
<pre><code class="solidity language-solidity">function service() external view returns (contract IService)</code></pre>
<h3 id="companies_manager_role">COMPANIES_MANAGER_ROLE</h3>
<pre><code class="solidity language-solidity">function COMPANIES_MANAGER_ROLE() external view returns (bytes32)</code></pre>
<h3 id="hasrole">hasRole</h3>
<pre><code class="solidity language-solidity">function hasRole(bytes32 role, address account) external view returns (bool)</code></pre>
<h3 id="log-2">log</h3>
<pre><code class="solidity language-solidity">function log(address sender, address receiver, uint256 value, bytes data) external</code></pre>
<h2 id="itokensregistry">ITokensRegistry</h2>
<h3 id="istokenwhitelisted">isTokenWhitelisted</h3>
<pre><code class="solidity language-solidity">function isTokenWhitelisted(address token) external view returns (bool)</code></pre>
<h2 id="exceptionslibrary">ExceptionsLibrary</h2>
<h3 id="address_zero">ADDRESS_ZERO</h3>
<pre><code class="solidity language-solidity">string ADDRESS_ZERO</code></pre>
<h3 id="incorrect_eth_passed">INCORRECT_ETH_PASSED</h3>
<pre><code class="solidity language-solidity">string INCORRECT_ETH_PASSED</code></pre>
<h3 id="no_company">NO_COMPANY</h3>
<pre><code class="solidity language-solidity">string NO_COMPANY</code></pre>
<h3 id="invalid_token">INVALID_TOKEN</h3>
<pre><code class="solidity language-solidity">string INVALID_TOKEN</code></pre>
<h3 id="not_pool">NOT_POOL</h3>
<pre><code class="solidity language-solidity">string NOT_POOL</code></pre>
<h3 id="not_tge">NOT_TGE</h3>
<pre><code class="solidity language-solidity">string NOT_TGE</code></pre>
<h3 id="not_registry">NOT_Registry</h3>
<pre><code class="solidity language-solidity">string NOT_Registry</code></pre>
<h3 id="not_pool_owner">NOT_POOL_OWNER</h3>
<pre><code class="solidity language-solidity">string NOT_POOL_OWNER</code></pre>
<h3 id="not_service_owner">NOT_SERVICE_OWNER</h3>
<pre><code class="solidity language-solidity">string NOT_SERVICE_OWNER</code></pre>
<h3 id="is_dao">IS_DAO</h3>
<pre><code class="solidity language-solidity">string IS_DAO</code></pre>
<h3 id="not_dao">NOT_DAO</h3>
<pre><code class="solidity language-solidity">string NOT_DAO</code></pre>
<h3 id="not_whitelisted">NOT_WHITELISTED</h3>
<pre><code class="solidity language-solidity">string NOT_WHITELISTED</code></pre>
<h3 id="not_service">NOT_SERVICE</h3>
<pre><code class="solidity language-solidity">string NOT_SERVICE</code></pre>
<h3 id="wrong_state">WRONG_STATE</h3>
<pre><code class="solidity language-solidity">string WRONG_STATE</code></pre>
<h3 id="transfer_failed">TRANSFER_FAILED</h3>
<pre><code class="solidity language-solidity">string TRANSFER_FAILED</code></pre>
<h3 id="claim_not_available">CLAIM_NOT_AVAILABLE</h3>
<pre><code class="solidity language-solidity">string CLAIM_NOT_AVAILABLE</code></pre>
<h3 id="no_locked_balance">NO_LOCKED_BALANCE</h3>
<pre><code class="solidity language-solidity">string NO_LOCKED_BALANCE</code></pre>
<h3 id="lockup_tvl_reached">LOCKUP_TVL_REACHED</h3>
<pre><code class="solidity language-solidity">string LOCKUP_TVL_REACHED</code></pre>
<h3 id="hardcap_overflow">HARDCAP_OVERFLOW</h3>
<pre><code class="solidity language-solidity">string HARDCAP_OVERFLOW</code></pre>
<h3 id="max_purchase_overflow">MAX_PURCHASE_OVERFLOW</h3>
<pre><code class="solidity language-solidity">string MAX_PURCHASE_OVERFLOW</code></pre>
<h3 id="hardcap_overflow_remaining_supply">HARDCAP_OVERFLOW_REMAINING_SUPPLY</h3>
<pre><code class="solidity language-solidity">string HARDCAP_OVERFLOW_REMAINING_SUPPLY</code></pre>
<h3 id="hardcap_and_protocol_fee_overflow_remaining_supply">HARDCAP_AND_PROTOCOL_FEE_OVERFLOW_REMAINING_SUPPLY</h3>
<pre><code class="solidity language-solidity">string HARDCAP_AND_PROTOCOL_FEE_OVERFLOW_REMAINING_SUPPLY</code></pre>
<h3 id="min_purchase_underflow">MIN_PURCHASE_UNDERFLOW</h3>
<pre><code class="solidity language-solidity">string MIN_PURCHASE_UNDERFLOW</code></pre>
<h3 id="low_unlocked_balance">LOW_UNLOCKED_BALANCE</h3>
<pre><code class="solidity language-solidity">string LOW_UNLOCKED_BALANCE</code></pre>
<h3 id="zero_purchase_amount">ZERO_PURCHASE_AMOUNT</h3>
<pre><code class="solidity language-solidity">string ZERO_PURCHASE_AMOUNT</code></pre>
<h3 id="nothing_to_redeem">NOTHING_TO_REDEEM</h3>
<pre><code class="solidity language-solidity">string NOTHING_TO_REDEEM</code></pre>
<h3 id="record_in_use">RECORD_IN_USE</h3>
<pre><code class="solidity language-solidity">string RECORD_IN_USE</code></pre>
<h3 id="invalid_ein">INVALID_EIN</h3>
<pre><code class="solidity language-solidity">string INVALID_EIN</code></pre>
<h3 id="value_zero">VALUE_ZERO</h3>
<pre><code class="solidity language-solidity">string VALUE_ZERO</code></pre>
<h3 id="already_set">ALREADY_SET</h3>
<pre><code class="solidity language-solidity">string ALREADY_SET</code></pre>
<h3 id="voting_finished">VOTING_FINISHED</h3>
<pre><code class="solidity language-solidity">string VOTING_FINISHED</code></pre>
<h3 id="already_executed">ALREADY_EXECUTED</h3>
<pre><code class="solidity language-solidity">string ALREADY_EXECUTED</code></pre>
<h3 id="active_tge_exists">ACTIVE_TGE_EXISTS</h3>
<pre><code class="solidity language-solidity">string ACTIVE_TGE_EXISTS</code></pre>
<h3 id="invalid_value">INVALID_VALUE</h3>
<pre><code class="solidity language-solidity">string INVALID_VALUE</code></pre>
<h3 id="invalid_cap">INVALID_CAP</h3>
<pre><code class="solidity language-solidity">string INVALID_CAP</code></pre>
<h3 id="invalid_hardcap">INVALID_HARDCAP</h3>
<pre><code class="solidity language-solidity">string INVALID_HARDCAP</code></pre>
<h3 id="only_pool">ONLY_POOL</h3>
<pre><code class="solidity language-solidity">string ONLY_POOL</code></pre>
<h3 id="eth_transfer_fail">ETH_TRANSFER_FAIL</h3>
<pre><code class="solidity language-solidity">string ETH_TRANSFER_FAIL</code></pre>
<h3 id="token_transfer_fail">TOKEN_TRANSFER_FAIL</h3>
<pre><code class="solidity language-solidity">string TOKEN_TRANSFER_FAIL</code></pre>
<h3 id="service_paused">SERVICE_PAUSED</h3>
<pre><code class="solidity language-solidity">string SERVICE_PAUSED</code></pre>
<h3 id="invalid_proposal_type">INVALID_PROPOSAL_TYPE</h3>
<pre><code class="solidity language-solidity">string INVALID_PROPOSAL_TYPE</code></pre>
<h3 id="execution_failed">EXECUTION_FAILED</h3>
<pre><code class="solidity language-solidity">string EXECUTION_FAILED</code></pre>
<h3 id="invalid_user">INVALID_USER</h3>
<pre><code class="solidity language-solidity">string INVALID_USER</code></pre>
<h3 id="not_launched">NOT_LAUNCHED</h3>
<pre><code class="solidity language-solidity">string NOT_LAUNCHED</code></pre>
<h3 id="launched">LAUNCHED</h3>
<pre><code class="solidity language-solidity">string LAUNCHED</code></pre>
<h3 id="vesting_tvl_reached">VESTING_TVL_REACHED</h3>
<pre><code class="solidity language-solidity">string VESTING_TVL_REACHED</code></pre>
<h3 id="wrong_token_address">WRONG_TOKEN_ADDRESS</h3>
<pre><code class="solidity language-solidity">string WRONG_TOKEN_ADDRESS</code></pre>
<h3 id="governance_token_exists">GOVERNANCE_TOKEN_EXISTS</h3>
<pre><code class="solidity language-solidity">string GOVERNANCE_TOKEN_EXISTS</code></pre>
<h3 id="threshold_not_reached">THRESHOLD_NOT_REACHED</h3>
<pre><code class="solidity language-solidity">string THRESHOLD_NOT_REACHED</code></pre>
<h3 id="unsupported_token_type">UNSUPPORTED_TOKEN_TYPE</h3>
<pre><code class="solidity language-solidity">string UNSUPPORTED_TOKEN_TYPE</code></pre>
<h3 id="already_voted">ALREADY_VOTED</h3>
<pre><code class="solidity language-solidity">string ALREADY_VOTED</code></pre>
<h3 id="zero_votes">ZERO_VOTES</h3>
<pre><code class="solidity language-solidity">string ZERO_VOTES</code></pre>
<h3 id="active_governance_settings_proposal_exists">ACTIVE_GOVERNANCE_SETTINGS_PROPOSAL_EXISTS</h3>
<pre><code class="solidity language-solidity">string ACTIVE_GOVERNANCE_SETTINGS_PROPOSAL_EXISTS</code></pre>
<h3 id="empty_address">EMPTY_ADDRESS</h3>
<pre><code class="solidity language-solidity">string EMPTY_ADDRESS</code></pre>
<h3 id="not_valid_proposer">NOT_VALID_PROPOSER</h3>
<pre><code class="solidity language-solidity">string NOT_VALID_PROPOSER</code></pre>
<h3 id="shares_sum_exceeds_one">SHARES_SUM_EXCEEDS_ONE</h3>
<pre><code class="solidity language-solidity">string SHARES_SUM_EXCEEDS_ONE</code></pre>
<h3 id="not_resolver">NOT_RESOLVER</h3>
<pre><code class="solidity language-solidity">string NOT_RESOLVER</code></pre>
<h3 id="not_registry-1">NOT_REGISTRY</h3>
<pre><code class="solidity language-solidity">string NOT_REGISTRY</code></pre>
<h3 id="invalid_target">INVALID_TARGET</h3>
<pre><code class="solidity language-solidity">string INVALID_TARGET</code></pre>
<h3 id="not_tge_factory">NOT_TGE_FACTORY</h3>
<pre><code class="solidity language-solidity">string NOT_TGE_FACTORY</code></pre>
<h3 id="wrong_amount">WRONG_AMOUNT</h3>
<pre><code class="solidity language-solidity">string WRONG_AMOUNT</code></pre>
<h3 id="wrong_block_number">WRONG_BLOCK_NUMBER</h3>
<pre><code class="solidity language-solidity">string WRONG_BLOCK_NUMBER</code></pre>
<h3 id="not_valid_executor">NOT_VALID_EXECUTOR</h3>
<pre><code class="solidity language-solidity">string NOT_VALID_EXECUTOR</code></pre>
<h3 id="pool_paused">POOL_PAUSED</h3>
<pre><code class="solidity language-solidity">string POOL_PAUSED</code></pre>
<h3 id="not_invoice_manager">NOT_INVOICE_MANAGER</h3>
<pre><code class="solidity language-solidity">string NOT_INVOICE_MANAGER</code></pre>
<h3 id="wrong_resolver">WRONG_RESOLVER</h3>
<pre><code class="solidity language-solidity">string WRONG_RESOLVER</code></pre>
<h2 id="companiesregistry">CompaniesRegistry</h2>
<p>This contract is a section of the Registry contract designed for storing and manipulating companies listed for sale.</p>
<p><em>With the help of this contract, one can find out the number of companies available for purchase in a specific jurisdiction and their corresponding prices. Here, an isolated but still dependent role-based model based on Access Control from OZ is implemented, with the contract Service playing a crucial role.</em></p>
<h3 id="companies_manager_role-1">COMPANIES_MANAGER_ROLE</h3>
<pre><code class="solidity language-solidity">bytes32 COMPANIES_MANAGER_ROLE</code></pre>
<p>Hash code for the COMPANIES_MANAGER role in the OpenZeppelin (OZ) Access Control model.</p>
<p><em>This role is intended for working with the showcase of companies available for purchase and can also add and modify the link to the organization's charter. It operates only within the Registry contract through a separate AccessControl model from OpenZeppelin with standard methods: grantRole, revokeRole, setRole.
    Methods:
    - CompaniesRegistry.sol:createCompany(CompanyInfo calldata info) - creating a company with specified immutable data and its price in ETH, deploying the contract with a temporary owner in the form of the Registry contract proxy address. After calling such a method, the company immediately becomes available for purchase.
    - CompaniesRegistry.sol:deleteCompany(uint256 jurisdiction, uint256 entityType, uint256 id) - deleting a company record (removing it from sale without the possibility of recovery).
    - CompaniesRegistry.sol:updateCompanyFee(uint256 jurisdiction, uint256 entityType, uint256 id, uint256 fee) - changing the price of an unsold company (prices are set in ETH).
    - Pool.sol:setOAUrl(string memory _uri) - changing the link to the pool's operating agreement.
    Storage, assignment, and revocation of the role are carried out using the standard methods of the AccessControl model from OpenZeppelin: grantRole, revokeRole, setRole. The holder of the standard ADMIN_ROLE of this contract can manage this role (by default - the address that deployed the contract).</em></p>
<h3 id="queue">queue</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; mapping(uint256 =&gt; uint256[])) queue</code></pre>
<p><em>The embedded mappings form a construction, when accessed using two keys at once [jurisdiction][EntityType], you can get lists of ordinal numbers of company records added by managers. These serial numbers can be used when contacting mapping companies to obtain public legal information about the company awaiting purchase by the client.</em></p>
<h3 id="companies">companies</h3>
<pre><code class="solidity language-solidity">mapping(uint256 =&gt; struct ICompaniesRegistry.CompanyInfo) companies</code></pre>
<p><em>In this mapping, public legal information is stored about companies that are ready to be acquired by the client and start working as a DAO. The appeal takes place according to the serial number - the key. A list of keys for each type of company and each jurisdiction can be obtained in the queue mapping.</em></p>
<h3 id="lastcompanyindex">lastCompanyIndex</h3>
<pre><code class="solidity language-solidity">uint256 lastCompanyIndex</code></pre>
<p><em>The last sequential number of the last record created by managers in the queue with company data is stored here.</em></p>
<h3 id="companyindex">companyIndex</h3>
<pre><code class="solidity language-solidity">mapping(bytes32 =&gt; uint256) companyIndex</code></pre>
<p><em>Status of combination of (jurisdiction, entityType, EIN) existing</em></p>
<h3 id="companycreated">CompanyCreated</h3>
<pre><code class="solidity language-solidity">event CompanyCreated(uint256 index, address poolAddress)</code></pre>
<p><em>An event emitted when a manager creates a new company. After this event, the company immediately becomes available for purchase.</em></p>
<h4 id="parameters-171">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>uint256</td>
<td>Company list index.</td>
</tr>
<tr>
<td>poolAddress</td>
<td>address</td>
<td>The contract pool address computed based on the bytecode and initial arguments.</td>
</tr>
</tbody>
</table>
<h3 id="companydeleted">CompanyDeleted</h3>
<pre><code class="solidity language-solidity">event CompanyDeleted(uint256 metadataIndex)</code></pre>
<p><em>An event emitted when a company is delisted from sale. This is one of the mechanisms to modify legal information regarding the company.</em></p>
<h4 id="parameters-172">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>metadataIndex</td>
<td>uint256</td>
<td>Company metadata index.</td>
</tr>
</tbody>
</table>
<h3 id="companyfeeupdated">CompanyFeeUpdated</h3>
<pre><code class="solidity language-solidity">event CompanyFeeUpdated(uint256 jurisdiction, uint256 entityType, uint256 id, uint256 fee)</code></pre>
<p><em>The event is issued when the manager changes the price of an already created company ready for purchase by the client.</em></p>
<h4 id="parameters-173">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>jurisdiction</td>
<td>uint256</td>
<td>The digital code of the jurisdiction.</td>
</tr>
<tr>
<td>entityType</td>
<td>uint256</td>
<td>The digital code of the organization type.</td>
</tr>
<tr>
<td>id</td>
<td>uint256</td>
<td>Queue index</td>
</tr>
<tr>
<td>fee</td>
<td>uint256</td>
<td>Fee for createPool</td>
</tr>
</tbody>
</table>
<h3 id="createcompany-1">createCompany</h3>
<pre><code class="solidity language-solidity">function createCompany(struct ICompaniesRegistry.CompanyInfo info) public</code></pre>
<p><em>Create company record - A method for creating a new company record, including its legal data and the sale price.</em></p>
<h4 id="parameters-174">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>info</td>
<td>struct ICompaniesRegistry.CompanyInfo</td>
<td>Company Info</td>
</tr>
</tbody>
</table>
<h3 id="lockcompany-1">lockCompany</h3>
<pre><code class="solidity language-solidity">function lockCompany(uint256 jurisdiction, uint256 entityType) external returns (struct ICompaniesRegistry.CompanyInfo info)</code></pre>
<p>Lock company record</p>
<p><em>Booking the company for the buyer. During the acquisition of a company, this method searches for a free company at the request of the client (jurisdiction and type of organization), if such exist in the company’s storage reserve, then the method selects the last of the added companies, extracts its record data and sends it as a response for further work of the Service contract, removes its record from the Registry.</em></p>
<h4 id="parameters-175">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>jurisdiction</td>
<td>uint256</td>
<td>Цифровой код юрисдикции</td>
</tr>
<tr>
<td>entityType</td>
<td>uint256</td>
<td>Цифровой код типа организакции</td>
</tr>
</tbody>
</table>
<h4 id="return-values-77">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>info</td>
<td>struct ICompaniesRegistry.CompanyInfo</td>
<td>Company info</td>
</tr>
</tbody>
</table>
<h3 id="deletecompany">deleteCompany</h3>
<pre><code class="solidity language-solidity">function deleteCompany(uint256 jurisdiction, uint256 entityType, uint256 id) external</code></pre>
<p><em>This method removes a record from the queue of created companies.</em></p>
<h4 id="parameters-176">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>jurisdiction</td>
<td>uint256</td>
<td>The digital code of the jurisdiction.</td>
</tr>
<tr>
<td>entityType</td>
<td>uint256</td>
<td>The digital code of the organization type.</td>
</tr>
<tr>
<td>id</td>
<td>uint256</td>
<td>Queue index.</td>
</tr>
</tbody>
</table>
<h3 id="updatecompanyfee">updateCompanyFee</h3>
<pre><code class="solidity language-solidity">function updateCompanyFee(uint256 jurisdiction, uint256 entityType, uint256 id, uint256 fee) external</code></pre>
<p><em>The method that the manager uses to change the value of the company already added earlier in the Registry.</em></p>
<h4 id="parameters-177">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>jurisdiction</td>
<td>uint256</td>
<td>The digital code of the jurisdiction.</td>
</tr>
<tr>
<td>entityType</td>
<td>uint256</td>
<td>The digital code of the organization type.</td>
</tr>
<tr>
<td>id</td>
<td>uint256</td>
<td>Queue index. @ param fee Fee to update.</td>
</tr>
<tr>
<td>fee</td>
<td>uint256</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="companyavailable">companyAvailable</h3>
<pre><code class="solidity language-solidity">function companyAvailable(uint256 jurisdiction, uint256 entityType) external view returns (bool)</code></pre>
<p><em>This view method is designed to find out whether there is at least one company available for purchase for the jurisdiction and type of organization selected by the user.</em></p>
<h4 id="parameters-178">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>jurisdiction</td>
<td>uint256</td>
<td>The digital code of the jurisdiction.</td>
</tr>
<tr>
<td>entityType</td>
<td>uint256</td>
<td>The digital code of the organization type.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-78">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>"True" if at least one company is available</td>
</tr>
</tbody>
</table>
<h3 id="getcompanypooladdress">getCompanyPoolAddress</h3>
<pre><code class="solidity language-solidity">function getCompanyPoolAddress(uint256 jurisdiction, uint256 entityType, uint256 id) public view returns (address)</code></pre>
<p><em>Get company pool address by metadata</em></p>
<h4 id="parameters-179">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>jurisdiction</td>
<td>uint256</td>
<td>Jurisdiction</td>
</tr>
<tr>
<td>entityType</td>
<td>uint256</td>
<td>Entity type</td>
</tr>
<tr>
<td>id</td>
<td>uint256</td>
<td>Queue id</td>
</tr>
</tbody>
</table>
<h4 id="return-values-79">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address</td>
<td>Future company's pool address</td>
</tr>
</tbody>
</table>
<h3 id="getcompany">getCompany</h3>
<pre><code class="solidity language-solidity">function getCompany(uint256 jurisdiction, uint256 entityType, string ein) external view returns (struct ICompaniesRegistry.CompanyInfo)</code></pre>
<p><em>This method allows obtaining all the data of a company, including its legal data, that is still available for sale.</em></p>
<h4 id="parameters-180">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>jurisdiction</td>
<td>uint256</td>
<td>The digital code of the jurisdiction.</td>
</tr>
<tr>
<td>entityType</td>
<td>uint256</td>
<td>The digital code of the organization type.</td>
</tr>
<tr>
<td>ein</td>
<td>string</td>
<td>The government registration number.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-80">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>struct ICompaniesRegistry.CompanyInfo</td>
<td>CompanyInfo The company data.</td>
</tr>
</tbody>
</table>
<h3 id="getavailablecompanyaddress">getAvailableCompanyAddress</h3>
<pre><code class="solidity language-solidity">function getAvailableCompanyAddress(uint256 jurisdiction, uint256 entityType) external view returns (address)</code></pre>
<p><em>This method allows obtaining the contract address of a company that is available for sale and meets the conditions based on its jurisdiction and entity type.</em></p>
<h4 id="parameters-181">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>jurisdiction</td>
<td>uint256</td>
<td>The digital code of the jurisdiction.</td>
</tr>
<tr>
<td>entityType</td>
<td>uint256</td>
<td>The digital code of the organization type.</td>
</tr>
</tbody>
</table>
<h4 id="return-values-81">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address</td>
<td>address The contract pool address.</td>
</tr>
</tbody>
</table>
<h3 id="setcompanyinfoforpool">setCompanyInfoForPool</h3>
<pre><code class="solidity language-solidity">function setCompanyInfoForPool(contract IPool pool, uint256 _jurisdiction, uint256 _entityType, string _ein, string _dateOfIncorporation, string _OAuri) external</code></pre>
<p>Method for replacing the reference to the Operating Agreement and legal data of a company in the contract's memory.</p>
<p><em>This is a special method for the manager to service contracts of already acquired companies. To correct data in a company that has not been acquired yet, the record should be deleted and a new one created.</em></p>
<h4 id="parameters-182">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>contract IPool</td>
<td>The contract pool address.</td>
</tr>
<tr>
<td>_jurisdiction</td>
<td>uint256</td>
<td>The digital code of the jurisdiction.</td>
</tr>
<tr>
<td>_entityType</td>
<td>uint256</td>
<td>The digital code of the organization type.</td>
</tr>
<tr>
<td>_ein</td>
<td>string</td>
<td>The government registration number.</td>
</tr>
<tr>
<td>_dateOfIncorporation</td>
<td>string</td>
<td>The date of incorporation.</td>
</tr>
<tr>
<td>_OAuri</td>
<td>string</td>
<td>Operating Agreement URL.</td>
</tr>
</tbody>
</table>
<h2 id="recordsregistry">RecordsRegistry</h2>
<p><a href="https://github.com/title">@title</a> Registry Contract<br />
 <a href="https://github.com/notice">@notice</a> This contract complements the Registry and serves as a storage or all entities created by users of the protocol.</p>
<p><em>Unlike the Companies Registry, this contract is managed solely by other protocol contracts without operator intervention, and logs all deployed contracts and their associated events.</em></p>
<h3 id="contractrecords">contractRecords</h3>
<pre><code class="solidity language-solidity">struct IRecordsRegistry.ContractInfo[] contractRecords</code></pre>
<p><em>In this array, records are stored about all contracts created by users (that is, about those generated by the service), namely, its index, with which you can extract all available information from other getters.</em></p>
<h3 id="contractindex">ContractIndex</h3>
<pre><code class="solidity language-solidity">struct ContractIndex {
  bool exists;
  uint160 index;
}</code></pre>
<h3 id="indexofcontract">indexOfContract</h3>
<pre><code class="solidity language-solidity">mapping(address =&gt; struct RecordsRegistry.ContractIndex) indexOfContract</code></pre>
<p><em>Mapping of contract addresses to their record indexes</em></p>
<h3 id="proposalrecords">proposalRecords</h3>
<pre><code class="solidity language-solidity">struct IRecordsRegistry.ProposalInfo[] proposalRecords</code></pre>
<p><em>List of proposal records</em></p>
<h3 id="events">events</h3>
<pre><code class="solidity language-solidity">struct IRecordsRegistry.Event[] events</code></pre>
<p><em>A list of existing events. An event can be either a contract or a specific action performed by a pool based on the results of voting for a promotion (for example, the transfer of funds from a pool contract is considered an event, but does not have a contract, and TGE has both the status of an event and its own separate contract).</em></p>
<h3 id="contractrecordadded">ContractRecordAdded</h3>
<pre><code class="solidity language-solidity">event ContractRecordAdded(uint256 index, address addr, enum IRecordsRegistry.ContractType contractType)</code></pre>
<p><em>Event emitted on creation of contract record</em></p>
<h4 id="parameters-183">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>uint256</td>
<td>Record index</td>
</tr>
<tr>
<td>addr</td>
<td>address</td>
<td>Contract address</td>
</tr>
<tr>
<td>contractType</td>
<td>enum IRecordsRegistry.ContractType</td>
<td>Contract type</td>
</tr>
</tbody>
</table>
<h3 id="proposalrecordadded">ProposalRecordAdded</h3>
<pre><code class="solidity language-solidity">event ProposalRecordAdded(uint256 index, address pool, uint256 proposalId)</code></pre>
<p><em>Event emitted on creation of proposal record</em></p>
<h4 id="parameters-184">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>uint256</td>
<td>Record index</td>
</tr>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="eventrecordadded">EventRecordAdded</h3>
<pre><code class="solidity language-solidity">event EventRecordAdded(uint256 index, enum IRecordsRegistry.EventType eventType, address pool, uint256 proposalId)</code></pre>
<p><em>Event emitted on creation of event</em></p>
<h4 id="parameters-185">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>uint256</td>
<td>Record index</td>
</tr>
<tr>
<td>eventType</td>
<td>enum IRecordsRegistry.EventType</td>
<td>Event type</td>
</tr>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h3 id="addcontractrecord-1">addContractRecord</h3>
<pre><code class="solidity language-solidity">function addContractRecord(address addr, enum IRecordsRegistry.ContractType contractType, string description) external returns (uint256 index)</code></pre>
<p><em>This method is used by the main Service contract in order to save the data of the contracts it deploys. After the Registry contract receives the address and type of the created contract from the Service contract, it sends back as a response the sequence number/index assigned to the new record.</em></p>
<h4 id="parameters-186">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>addr</td>
<td>address</td>
<td>Contract address</td>
</tr>
<tr>
<td>contractType</td>
<td>enum IRecordsRegistry.ContractType</td>
<td>Contract type</td>
</tr>
<tr>
<td>description</td>
<td>string</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="return-values-82">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>uint256</td>
<td>Record index</td>
</tr>
</tbody>
</table>
<h3 id="addproposalrecord-1">addProposalRecord</h3>
<pre><code class="solidity language-solidity">function addProposalRecord(address pool, uint256 proposalId) external returns (uint256 index)</code></pre>
<p><em>This method accepts data from the Service contract about the created nodes in the pools. If there is an internal index of the proposal in the contract of the pool whose shareholders created the proposal, then as a result of using this method, the proposal is given a global index for the entire ecosystem.</em></p>
<h4 id="parameters-187">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
</tbody>
</table>
<h4 id="return-values-83">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>uint256</td>
<td>Record index</td>
</tr>
</tbody>
</table>
<h3 id="addeventrecord-1">addEventRecord</h3>
<pre><code class="solidity language-solidity">function addEventRecord(address pool, enum IRecordsRegistry.EventType eventType, address eventContract, uint256 proposalId, string metaHash) external returns (uint256 index)</code></pre>
<p><em>This method is used to register events - specific entities associated with the operational activities of pools and the transfer of various values as a result of the use of ecosystem contracts. Each event also has a metahash string field, which is the identifier of the private description of the event stored on the backend.</em></p>
<h4 id="parameters-188">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Pool address</td>
</tr>
<tr>
<td>eventType</td>
<td>enum IRecordsRegistry.EventType</td>
<td>Event type</td>
</tr>
<tr>
<td>eventContract</td>
<td>address</td>
<td>Address of the event contract</td>
</tr>
<tr>
<td>proposalId</td>
<td>uint256</td>
<td>Proposal ID</td>
</tr>
<tr>
<td>metaHash</td>
<td>string</td>
<td>Hash value of event metadata</td>
</tr>
</tbody>
</table>
<h4 id="return-values-84">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>uint256</td>
<td>Record index</td>
</tr>
</tbody>
</table>
<h3 id="setglobalproposalid-1">setGlobalProposalId</h3>
<pre><code class="solidity language-solidity">function setGlobalProposalId(address pool, uint256 proposalId, uint256 globalProposalId) internal virtual</code></pre>
<h3 id="typeof-1">typeOf</h3>
<pre><code class="solidity language-solidity">function typeOf(address addr) public view returns (enum IRecordsRegistry.ContractType)</code></pre>
<p>Returns type of given contract</p>
<h4 id="parameters-189">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>addr</td>
<td>address</td>
<td>Address of contract</td>
</tr>
</tbody>
</table>
<h4 id="return-values-85">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>enum IRecordsRegistry.ContractType</td>
<td>Contract type</td>
</tr>
</tbody>
</table>
<h3 id="contractrecordscount">contractRecordsCount</h3>
<pre><code class="solidity language-solidity">function contractRecordsCount() external view returns (uint256)</code></pre>
<p>Returns number of contract records</p>
<h4 id="return-values-86">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>Contract records count</td>
</tr>
</tbody>
</table>
<h3 id="proposalrecordscount">proposalRecordsCount</h3>
<pre><code class="solidity language-solidity">function proposalRecordsCount() external view returns (uint256)</code></pre>
<p>Returns number of proposal records</p>
<h4 id="return-values-87">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>Proposal records count</td>
</tr>
</tbody>
</table>
<h3 id="eventrecordscount">eventRecordsCount</h3>
<pre><code class="solidity language-solidity">function eventRecordsCount() external view returns (uint256)</code></pre>
<p>Returns number of event records</p>
<h4 id="return-values-88">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>Event records count</td>
</tr>
</tbody>
</table>
<h2 id="registrybase">RegistryBase</h2>
<p>The core contract for the Registry contracts.</p>
<p><em>This abstract contract is inherited by the Registry contract and contains functions and modifiers that could be applied to all contracts in this section.</em></p>
<h3 id="service-11">service</h3>
<pre><code class="solidity language-solidity">address service</code></pre>
<p><em>The address of the Service contract.</em></p>
<h3 id="onlyservice-2">onlyService</h3>
<pre><code class="solidity language-solidity">modifier onlyService()</code></pre>
<p>Modifier that allows calling the method only from the Service contract.</p>
<h3 id="onlyserviceorfactory">onlyServiceOrFactory</h3>
<pre><code class="solidity language-solidity">modifier onlyServiceOrFactory()</code></pre>
<p>Modifier that allows calling the method only from the Service, TGEFactory, and TokenFactory contracts.</p>
<h3 id="__registrybase_init">__RegistryBase_init</h3>
<pre><code class="solidity language-solidity">function __RegistryBase_init() internal</code></pre>
<p><em>This method is executed during deployment or upgrade of the contract to set the contract initiator as the contract administrator. Without binding from the Service contract, this method cannot provide unauthorized access in any way.</em></p>
<h3 id="setservice-1">setService</h3>
<pre><code class="solidity language-solidity">function setService(address service_) external</code></pre>
<p><em>This method is executed during deployment and upgrade of the contract to link the main protocol contract with the Registry data storage by storing the address of the Service contract.</em></p>
<h2 id="tokensregistry">TokensRegistry</h2>
<h3 id="whitelisted_token_role">WHITELISTED_TOKEN_ROLE</h3>
<pre><code class="solidity language-solidity">bytes32 WHITELISTED_TOKEN_ROLE</code></pre>
<p><em>Whitelisted token role</em></p>
<h3 id="whitelisttokens">whitelistTokens</h3>
<pre><code class="solidity language-solidity">function whitelistTokens(address[] tokens) external</code></pre>
<h3 id="istokenwhitelisted-1">isTokenWhitelisted</h3>
<pre><code class="solidity language-solidity">function isTokenWhitelisted(address token) external view returns (bool)</code></pre>
<p><em>Check if token is whitelisted</em></p>
<h4 id="parameters-190">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>token</td>
<td>address</td>
<td>Token</td>
</tr>
</tbody>
</table>
<h4 id="return-values-89">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bool</td>
<td>Is token whitelisted</td>
</tr>
</tbody>
</table>
<h2 id="erc20mock">ERC20Mock</h2>
<h3 id="constructor-10">constructor</h3>
<pre><code class="solidity language-solidity">constructor(string name_, string symbol_) public</code></pre>
<h2 id="iuniswapfactory">IUniswapFactory</h2>
<h2 id="iuniswappositionmanager">IUniswapPositionManager</h2>
<h3 id="createandinitializepoolifnecessary">createAndInitializePoolIfNecessary</h3>
<pre><code class="solidity language-solidity">function createAndInitializePoolIfNecessary(address token0, address token1, uint24 fee, uint160 sqrtPriceX96) external payable returns (address pool)</code></pre>
<p>Creates a new pool if it does not exist, then initializes if not initialized</p>
<p><em>This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool</em></p>
<h4 id="parameters-191">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>token0</td>
<td>address</td>
<td>The contract address of token0 of the pool</td>
</tr>
<tr>
<td>token1</td>
<td>address</td>
<td>The contract address of token1 of the pool</td>
</tr>
<tr>
<td>fee</td>
<td>uint24</td>
<td>The fee amount of the v3 pool for the specified token pair</td>
</tr>
<tr>
<td>sqrtPriceX96</td>
<td>uint160</td>
<td>The initial square root price of the pool as a Q64.96 value</td>
</tr>
</tbody>
</table>
<h4 id="return-values-90">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pool</td>
<td>address</td>
<td>Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary</td>
</tr>
</tbody>
</table>
<h3 id="multicall">multicall</h3>
<pre><code class="solidity language-solidity">function multicall(bytes[] data) external payable returns (bytes[] results)</code></pre>
<p>Call multiple functions in the current contract and return the data from all of them if they all succeed</p>
<p><em>The <code>msg.value</code> should not be trusted for any method callable from multicall.</em></p>
<h4 id="parameters-192">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>bytes[]</td>
<td>The encoded function data for each of the calls to make to this contract</td>
</tr>
</tbody>
</table>
<h4 id="return-values-91">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>results</td>
<td>bytes[]</td>
<td>The results from each of the calls passed in via data</td>
</tr>
</tbody>
</table>
<h3 id="mintparams">MintParams</h3>
<pre><code class="solidity language-solidity">struct MintParams {
  address token0;
  address token1;
  uint24 fee;
  int24 tickLower;
  int24 tickUpper;
  uint256 amount0Desired;
  uint256 amount1Desired;
  uint256 amount0Min;
  uint256 amount1Min;
  address recipient;
  uint256 deadline;
}</code></pre>
<h3 id="mint-4">mint</h3>
<pre><code class="solidity language-solidity">function mint(struct IUniswapPositionManager.MintParams params) external payable returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)</code></pre>
<p>Creates a new position wrapped in a NFT</p>
<p><em>Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
a method does not exist, i.e. the pool is assumed to be initialized.</em></p>
<h4 id="parameters-193">Parameters</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>params</td>
<td>struct IUniswapPositionManager.MintParams</td>
<td>The params necessary to mint a position, encoded as <code>MintParams</code> in calldata</td>
</tr>
</tbody>
</table>
<h4 id="return-values-92">Return Values</h4>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenId</td>
<td>uint256</td>
<td>The ID of the token that represents the minted position</td>
</tr>
<tr>
<td>liquidity</td>
<td>uint128</td>
<td>The amount of liquidity for this position</td>
</tr>
<tr>
<td>amount0</td>
<td>uint256</td>
<td>The amount of token0</td>
</tr>
<tr>
<td>amount1</td>
<td>uint256</td>
<td>The amount of token1</td>
</tr>
</tbody>
</table>
<h2 id="iweth">IWETH</h2>
<h3 id="deposit">deposit</h3>
<pre><code class="solidity language-solidity">function deposit() external payable</code></pre>
<p>Deposit ether to get wrapped ether</p>
<h3 id="withdraw">withdraw</h3>
<pre><code class="solidity language-solidity">function withdraw(uint256) external</code></pre>
<p>Withdraw wrapped ether to get ether</p>
<h2 id="governancetoken">GovernanceToken</h2>
<h3 id="constructor-11">constructor</h3>
<pre><code class="solidity language-solidity">constructor() public</code></pre>
<h3 id="initialize-15">initialize</h3>
<pre><code class="solidity language-solidity">function initialize() public</code></pre>
<h3 id="snapshot">snapshot</h3>
<pre><code class="solidity language-solidity">function snapshot() public</code></pre>
<h3 id="pause-1">pause</h3>
<pre><code class="solidity language-solidity">function pause() public</code></pre>
<h3 id="unpause-1">unpause</h3>
<pre><code class="solidity language-solidity">function unpause() public</code></pre>
<h3 id="mint-5">mint</h3>
<pre><code class="solidity language-solidity">function mint(address to, uint256 amount) public</code></pre>
<h3 id="_beforetokentransfer-1">_beforeTokenTransfer</h3>
<pre><code class="solidity language-solidity">function _beforeTokenTransfer(address from, address to, uint256 amount) internal</code></pre>
<h3 id="_aftertokentransfer-1">_afterTokenTransfer</h3>
<pre><code class="solidity language-solidity">function _afterTokenTransfer(address from, address to, uint256 amount) internal</code></pre>
<h3 id="_mint-1">_mint</h3>
<pre><code class="solidity language-solidity">function _mint(address to, uint256 amount) internal</code></pre>
<h3 id="_burn-1">_burn</h3>
<pre><code class="solidity language-solidity">function _burn(address account, uint256 amount) internal</code></pre>